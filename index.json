[{"categories":["6.S081"],"content":"MIT 6.S801实验4","date":"2022-11-08","objectID":"/mit-6.s081-lab4-traps/","tags":["操作系统"],"title":"MIT 6.S081 Lab4 Traps","uri":"/mit-6.s081-lab4-traps/"},{"categories":["6.S081"],"content":"课程知识 ","date":"2022-11-08","objectID":"/mit-6.s081-lab4-traps/:1:0","tags":["操作系统"],"title":"MIT 6.S081 Lab4 Traps","uri":"/mit-6.s081-lab4-traps/"},{"categories":["6.S081"],"content":"RISC和CISC xv6运行在RISC-V处理器上，RISC-V是精简指令集(RISC)，和传统以x86-64为代表的复杂指令集(CISC)存在一下区别： RISC拥有更少的指令数量，CISC需要向后兼容，指令数目会不断变大 RISC指令功能简单，可以减少CPU执行时间，CISC指令功能复杂，指令周期较长 ","date":"2022-11-08","objectID":"/mit-6.s081-lab4-traps/:1:1","tags":["操作系统"],"title":"MIT 6.S081 Lab4 Traps","uri":"/mit-6.s081-lab4-traps/"},{"categories":["6.S081"],"content":"栈 xv6每次调用函数，系统都会创建一个栈帧Stack Frame，系统通过移动栈指针Stack Pointer来完成Stack Frame的空间分配。栈从高地址向低地址增长，Stack Poiner需要向下移动来创建一个新的Stack Frame。xv6栈结构图如下所示： 每个Stack Frame均包含Retrun Address和指向前一个Frame的指针，同时会保存寄存器和一些本地变量，系统维护两个寄存器SP(Stack Pointer)和FP(Frame Pointer)，SP指向当前Frame的底部，FP指向当前Frame的顶部，可以通过FP找到每个栈中的固定位置的Return Address和指向前一个Frame的指针，保证函数正确调用和返回。 ","date":"2022-11-08","objectID":"/mit-6.s081-lab4-traps/:1:2","tags":["操作系统"],"title":"MIT 6.S081 Lab4 Traps","uri":"/mit-6.s081-lab4-traps/"},{"categories":["6.S081"],"content":"xv6的trap机制 从用户空间到内核空间的切换被称为陷入trap，trap是异常控制流的一种，trap分为三类 系统调用，异常和设备中断。 xv6的trap处理过程，以系统调用为例： 用户请求系统调用，将系统调用号写入a7寄存器，并调用ecall指令。 # kernel/usys.S ... .global write write: li a7, SYS_write ecall ret ... ecall指令执行内容： ecall将状态从用户态设置为内核态 将pc值保存在sepc寄存器中， 设置好stvec，即trapline page的起始位置uservec函数，跳转stvec寄存器指向的指令 ecall指令并不会切换页表，为了能在用户页表下可以执行uservec，用户页表必须包含uservec的映射。xv6利用trampoline page实现，trampoline page在用户空间和内核空间都映射到了相同的虚拟地址。trampoline page， 即蹦床页面很形象，即通过该页面从用户空间跳到了内核空间。 执行uservec函数 uservec执行的第一步是交换a0和SSCARTCH的值。SSCARTCH寄存器保存trapframe page的地址，这样我们就得到了trapframe page的地址，可以将32个寄存器保存在trapframe page中了。 xv6就每一个进程的trapframe分配一个页面，并安排它映射在用户虚拟地址的固定位置，位于trampoline page的下一个页面。 # kernel/trampoline.S # swap a0 and sscratch # so that a0 is TRAPFRAME csrrw a0, sscratch, a0 # save the user registers in TRAPFRAME sd ra, 40(a0) sd sp, 48(a0) sd gp, 56(a0) sd tp, 64(a0) sd t0, 72(a0) sd t1, 80(a0) ... sd t6, 280(a0) # save the user a0 in p-\u003etrapframe-\u003ea0 csrr t0, sscratch sd t0, 112(a0) 接下来加载内核栈到sp，确保内核程序正常运行；保存CPU的id到tp，用来获取当前进程；向t0写入usertrap的指针；向t1写入内核页表的地址并与SATP寄存器进行交换，完成页表的切换，跳转到usertrap执行 # kernel/trampoline.S # restore kernel stack pointer from p-\u003etrapframe-\u003ekernel_sp ld sp, 8(a0) # make tp hold the current hartid, from p-\u003etrapframe-\u003ekernel_hartid ld tp, 32(a0) # load the address of usertrap(), p-\u003etrapframe-\u003ekernel_trap ld t0, 16(a0) # restore kernel page table from p-\u003etrapframe-\u003ekernel_satp ld t1, 0(a0) csrw satp, t1 sfence.vma zero, zero # a0 is no longer valid, since the kernel page # table does not specially map p-\u003etf. # jump to usertrap(), which does not return jr t0 执行usertrap函数 首先设置寄存器，更改STVEC寄存器，指向内核空间trap处理代码的位置；将SEPC保存到trampframe中，防止程序执行过程中切换到另一个程序，另一个程序再调用系统调用导致SEPC数据被覆盖。 // kernel/trap.c w_stvec((uint64)kernelvec); struct proc *p = myproc(); // save user program counter. p-\u003etrapframe-\u003eepc = r_sepc(); 针对trap的来源进行分析，如果陷阱来自系统调用syscall会处理它，根据系统调用号查找相应的系统调用函数，执行真正的系统调用，将返回值保存在tramframe的a0寄存器中；如果是设备中断，devintr会处理；否则它是一个异常，内核会杀死错误进程。最后调用usertrapret函数。 // kernel/trap.c if(r_scause() == 8){ // system call if(p-\u003ekilled) exit(-1); // sepc points to the ecall instruction, // but we want to return to the next instruction. p-\u003etrapframe-\u003eepc += 4; // an interrupt will change sstatus \u0026c registers, // so don't enable until done with those registers. intr_on(); syscall(); } else if((which_dev = devintr()) != 0){ // ok } else { printf(\"usertrap(): unexpected scause %p pid=%d\\n\", r_scause(), p-\u003epid); printf(\" sepc=%p stval=%p\\n\", r_sepc(), r_stval()); p-\u003ekilled = 1; } if(p-\u003ekilled) exit(-1); 执行usertrapret，内核需要为返回内核空间做准备 关闭中断，更新STVEC寄存器，指向uservec；设置kernel page table的指针，内核栈指针，usertrap函数的指针到trapframe中；设置SSTATUS寄存器，便于下一次从用户空间到内核空间的跳转，并恢复程序计数器pc的值。 // kernel/trap.c p-\u003etrapframe-\u003ekernel_satp = r_satp(); // kernel page table p-\u003etrapframe-\u003ekernel_sp = p-\u003ekstack + PGSIZE; // process's kernel stack p-\u003etrapframe-\u003ekernel_trap = (uint64)usertrap; p-\u003etrapframe-\u003ekernel_hartid = r_tp(); // hartid for cpuid() ... w_sepc(p-\u003etrapframe-\u003eepc); 最后通过调用userret函数，将trapframe page的地址和用户页表的地址作为参数存储在a0，a1寄存器中，返回到用户空间的时候才能完成page table的切换。 uint64 fn = TRAMPOLINE + (userret - trampoline); ((void (*)(uint64,uint64))fn)(TRAPFRAME, satp); 最后执行userret 首先切换页表 csrw satp, a1 sfence.vma zero, zero # put the saved user a0 in sscratch, so we # can swap it with our a0 (TRAPFRAME) in the last step. ld t0, 112(a0) csrw sscratch, t0 接着恢复用户寄存器，最后调用sret，sret会打开中断，更改内核态为用户态，跳转pc指向的指令执行用户程序。 ","date":"2022-11-08","objectID":"/mit-6.s081-lab4-traps/:1:3","tags":["操作系统"],"title":"MIT 6.S081 Lab4 Traps","uri":"/mit-6.s081-lab4-traps/"},{"categories":["6.S081"],"content":"实验内容 ","date":"2022-11-08","objectID":"/mit-6.s081-lab4-traps/:2:0","tags":["操作系统"],"title":"MIT 6.S081 Lab4 Traps","uri":"/mit-6.s081-lab4-traps/"},{"categories":["6.S081"],"content":"RISC-V assembly (easy) RISC-V使用a0~a7共8个寄存器存储函数参数，若函数参数超过8个则需要存储在内存中，通过代码可以看出，13保存在a2寄存器中 # user/call.asm 24: 4635 li a2,13 通过代码看出，函数并没有对f调用 # user/call.asm 26: 45b1 li a1,12 printf的函数地址是0x640 auipc指令将高20位立即数左移12位加上pc后，存入ra寄存器，0x00000097对应的高20位左移12位之后为0x0，pc寄存器为0x30，因此ra寄存器的值为0x30，加上偏移量即为0x30 + 0x600(1536) = 0x630 # user/call.asm 30: 00000097 auipc ra,0x0 34: 600080e7 jalr 1536(ra) # 640 \u003cprintf\u003e printf的jalr之后的寄存器ra值是0x38 jalr指令当前PC+4保存在rd中，因此jalr之后寄存器ra值为0x34 + 0x4 = 0x38 程序输出HE110 World，大端需改成0x726c6400 57616不需要改 大端将高位存放在低地址，小段将高位存放在高地址 大端存储0x00646c72 00-64-6c-72 小段存储0x00646c72 72-6c-64-00 没有参数传a2寄存器，y显示的值是原来a2寄存器的值。 ","date":"2022-11-08","objectID":"/mit-6.s081-lab4-traps/:2:1","tags":["操作系统"],"title":"MIT 6.S081 Lab4 Traps","uri":"/mit-6.s081-lab4-traps/"},{"categories":["6.S081"],"content":"Backtrace(moderate) backtrace实验需要打印函数执行过程中每个stack frame的地址。stack frame的格式已经介绍。 首先根据提示添加函数添加到kernel/riscv.h中，获取保存在s0寄存器的帧指针fp。 static inline uint64 r_fp() { uint64 x; asm volatile(\"mv %0, s0\" : \"=r\" (x) ); return x; } 实现backtrace函数，首先获取帧指针fp，并获取页栈页面的顶部地址，接着就打印fp的地址，并通过frame中指向前一个frame的指针获取前一个frame。直到到达页顶部，即已经打印了所有stack frame的地址。（需要在kernel/defs.h中声明） // kernel/print.c void backtrace() { uint64 fp = r_fp(); uint64 stack_base = PGROUNDUP(fp); printf(\"backtrace:\\n\"); while(fp \u003c stack_base) { printf(\"%p\\n\", *((uint64*)(fp - 8))); fp = *((uint64*)(fp - 16)); } } ","date":"2022-11-08","objectID":"/mit-6.s081-lab4-traps/:2:2","tags":["操作系统"],"title":"MIT 6.S081 Lab4 Traps","uri":"/mit-6.s081-lab4-traps/"},{"categories":["6.S081"],"content":"Alarm(Hard) alarm实验要求我们在进程使用CPU的时间内，xv6定期向进程发出警报。 首先添加系统调用，并在user/usys.pl中添加 // user/user.h int sigalarm(int ticks, void (*handler)()); int sigreturn(void); 首先在进程结构体中添加字段，并在allocproc进行初始化和freeproc回收 // kernel/proc.h struct proc { ... int interval; //警报间隔 int tickcnt; //距离上一次调用经过了多少个时钟 uint64 handler; //警报处理函数 ... } // kernel/proc.c static struct proc* allocproc(void) { ... p-\u003einterval = 0; p-\u003etickcnt = 0; p-\u003ehandler = 0; // An empty user page table. p-\u003epagetable = proc_pagetable(p); ... } // kernel/proc.c static void freeproc(struct proc *p) { ... p-\u003einterval = 0; p-\u003etickcnt = 0; p-\u003ehandler = 0; } 实现真正的sys_sigalarm函数和sys_sigreturn函数 // kernel/syscall.h #define SYS_sigalarm 22 #define SYS_sigreturn 23 // kernel/syscall.c ... extern uint64 sys_sigalarm(void); extern uint64 sys_sigreturn(void); static uint64 (*syscalls[])(void) = { ... [SYS_sigalarm] sys_sigalarm, [SYS_sigreturn] sys_sigreturn, }; // kernel/sysproc.c uint64 sys_sigalarm(void) { if(argint(0, \u0026myproc()-\u003einterval) \u003c 0) return -1; if(argaddr(1, \u0026myproc()-\u003ehandler) \u003c 0) return -1; return 0; } uint64 sys_sigreturn(void) { return 0; } 修改usertrap，进程警报间隔期满时，设置pc值为警报处理函数handler的地址，同时清除时钟计数器 // kernel/trap.c if(which_dev == 2) { p-\u003etickcnt++; if(p-\u003eflag == 0 \u0026\u0026 p-\u003etickcnt == p-\u003einterval) { p-\u003etickcnt = 0; p-\u003etrapframe-\u003eepc = p-\u003ehandler; } yield(); } 我们在test0测试中系统调用返回时返回的handler的地址，会导致无法回到用户程序之中，我们需要在test1/test2中处理正确返回到用户代码和防止重复调用的问题。我们需要在进程结构体中再加入两个字段，并在allocproc进行初始化和freeproc回收。 // kernel/proc.h struct proc { ... int interval; //警报间隔 int tickcnt; //距离上一次调用经过了多少个时钟 uint64 handler; //警报处理函数 int flag; struct trapframe *alarm_trapframe; ... } 添加保存进程陷阱帧p-\u003etrapframe到p-\u003ealarm_trapframe，并置flag为1，防止handler重复调用 // kernel/trap.c if(which_dev == 2) { p-\u003etickcnt++; if(p-\u003eflag == 0 \u0026\u0026 p-\u003etickcnt == p-\u003einterval) { memmove(p-\u003ealarm_trapframe, p-\u003etrapframe, sizeof(struct trapframe)); p-\u003etickcnt = 0; p-\u003etrapframe-\u003eepc = p-\u003ehandler; p-\u003eflag = 1; } yield(); } 实现sys_sigreturn函数，当hanler调用sigreturn()时恢复陷阱帧，同时将flag置零，保证下一个handler能够调用。 // kernel/sysproc.c uint64 sys_sigreturn(void) { memmove(myproc()-\u003etrapframe, myproc()-\u003ealarm_trapframe, sizeof(struct trapframe)); myproc()-\u003eflag = 0; return 0; } ","date":"2022-11-08","objectID":"/mit-6.s081-lab4-traps/:2:3","tags":["操作系统"],"title":"MIT 6.S081 Lab4 Traps","uri":"/mit-6.s081-lab4-traps/"},{"categories":["6.S081"],"content":"MIT 6.S801实验3","date":"2022-10-30","objectID":"/mit-6.s081-lab3-pgtbl/","tags":["操作系统"],"title":"MIT 6.S081 Lab3 Pgtbl","uri":"/mit-6.s081-lab3-pgtbl/"},{"categories":["6.S081"],"content":"课程内容 ","date":"2022-10-30","objectID":"/mit-6.s081-lab3-pgtbl/:1:0","tags":["操作系统"],"title":"MIT 6.S081 Lab3 Pgtbl","uri":"/mit-6.s081-lab3-pgtbl/"},{"categories":["6.S081"],"content":"虚拟内存 实现操作系统的强隔离性，需要硬件的支持。除了分离用户态内核态的设计，让用户程序与内核相互独立，还有虚拟内存机制的设计，让用户程序之间相互独立，每个进程拥有自己的地址空间。引入虚拟内存之后，每个进程拥有独立的地址空间，用户无需直接操作物理内存，只需使用该进程的虚拟地址，虚拟内存会将虚拟地址转化为物理地址，从而避免出现一个进程覆盖另一个进程的内存地址。 ","date":"2022-10-30","objectID":"/mit-6.s081-lab3-pgtbl/:1:1","tags":["操作系统"],"title":"MIT 6.S081 Lab3 Pgtbl","uri":"/mit-6.s081-lab3-pgtbl/"},{"categories":["6.S081"],"content":"页表 页表是虚拟内存机制的核心，完成从虚拟地址到物理地址之间的映射。页表由页表项组成，页表项保存虚拟页号和物理页号映射。 页表是以页为粒度进行管理的，若以每个地址为粒度，则地址总线为64bit的机器需要管理2^64个地址，内存会被页表耗尽。 xv6中使用64位虚拟地址的低39bit，其中高27bit为页表索引，低12bit为页内偏移量offset，即页面大小为4KB。使用物理地址的低56bit，物理页号为其中高44bit，低12bit对应offset。通过页表索引得到物理块号，加上offset即为对应的物理地址。 页表保存在内存中，27bit的页表索引需要2^27个页表项来保存，每个页表项8B，需要占用大量连续内存，为此在xv6中引入三级页表。每个页表页拥有512个页表项，每个页表项都包含下一个页表页的物理地址，最低一级页表项对应的物理页号，加上低12bit的偏移量即为最终物理地址。 相比于单级页表： 节省内存，内核不必为整个目录分配连续的内存页面。 按需分配，只有在需要用到该页表索引对应的物理页时才进行分配 缺点在于必须从内存中加载三个PTE将虚拟地址转换成物理地址，需要访问内存三次，需要借助快表TLB提升效率。 TLB会保存虚拟地址到物理地址的映射关系，根据程序局部性原理，大大减少访存次数，提高寻址效率 xv6页表项为64bit，低10bit为各种标志位，包括读，写，执行等权限，中间44bit对应物理页号，高10bit保留。 内核页表 xv6为每个进程维护一个页表。描述每个进程的地址空间，还会维护一个单独的描述内核地址空间的页表，即内核页表。内核页表映射整个物理内存，内核设置了虚拟地址等于物理地址的映射关系，直接映射简化了读取或写入物理内存的内核代码。如通过虚拟地址查找物理地址时，先提取下一级页表的物理地址，然后将该物理地址作为虚拟地址获取下一级的页表项。 内核页表中除了直接映射之外，还存在特殊映射，即一个物理地址对应两个虚拟地址。 蹦床页面： 蹦床页面被映射了两次，包括直接映射和虚拟地址空间的顶部 内核栈页面 每个内核栈会被映射到高地址，便于在其虚拟地址下映射一个保护页(guard page)，内核栈溢出会引发一个异常，若栈溢出不会覆盖其他内存， 用户页表 xv6为每个进程维护一个用户页表，保存用户空间虚拟地址和物理地址之间的映射。 ","date":"2022-10-30","objectID":"/mit-6.s081-lab3-pgtbl/:1:2","tags":["操作系统"],"title":"MIT 6.S081 Lab3 Pgtbl","uri":"/mit-6.s081-lab3-pgtbl/"},{"categories":["6.S081"],"content":"实验内容 ","date":"2022-10-30","objectID":"/mit-6.s081-lab3-pgtbl/:2:0","tags":["操作系统"],"title":"MIT 6.S081 Lab3 Pgtbl","uri":"/mit-6.s081-lab3-pgtbl/"},{"categories":["6.S081"],"content":"Print a page table (easy) 该实验需要我们打印所有已分配的页表，由于xv6采用三级页表，因此我们需要通过递归的方式按级打印页表项地址和下一级页表的物理地址，参考/kernel/vm.c中的freewalk函数。 // kernel/vm.c void vmprinthelper(pagetable_t pagetable, int k) { if(k == 3) return; for(int i = 0; i \u003c 512; i++){ pte_t pte = pagetable[i]; if(pte \u0026 PTE_V){ printf(\"..\"); for(int j = 0; j \u003c k; j++) { printf(\" ..\"); } printf(\"%d: pte %p pa %p\\n\", i, pte, PTE2PA(pte)); vmprinthelper((pagetable_t)PTE2PA(pte), k + 1); } } } void vmprint(pagetable_t pagetable) { printf(\"page table %p\\n\", pagetable); vmprinthelper(pagetable, 0); } ","date":"2022-10-30","objectID":"/mit-6.s081-lab3-pgtbl/:2:1","tags":["操作系统"],"title":"MIT 6.S081 Lab3 Pgtbl","uri":"/mit-6.s081-lab3-pgtbl/"},{"categories":["6.S081"],"content":"A kernel page table per process (hard) xv6会为每一个用户进程提供一个用户页表，该页表包含用户内存的映射，而内核页表不包含这些映射，当内核需要使用在系统调用中传递的用户指针时，用户地址在内核中无效，需要先将其转化为物理地址，导致效率降低，我们的目标是允许内核直接解引用用户指针。 本实验需要先为每一个进程维护一个内核页表，进程在内核中执行时使用它自己的内核页表，同时需要为每个进程在内核页表中分配内核栈，最后需要将所有调用kernel_pagetable的地方替换为当前进程的内核页表。 在进程结构体中添加内核页表kernel_pagetable属性 // kernel/proc.h struct proc { ... pagetable_t kernel_pagetable; ... }; 实现kvmcreate()函数，在新进程创建时调用，参考kvminit() // kernel/vm.c pagetable_t kvmcreate() { pagetable_t user_kernel_pagetable = (pagetable_t) kalloc(); memset(user_kernel_pagetable, 0, PGSIZE); uvmmap(user_kernel_pagetable, UART0, UART0, PGSIZE, PTE_R | PTE_W); uvmmap(user_kernel_pagetable, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W); uvmmap(user_kernel_pagetable, CLINT, CLINT, 0x10000, PTE_R | PTE_W); uvmmap(user_kernel_pagetable, PLIC, PLIC, 0x400000, PTE_R | PTE_W); uvmmap(user_kernel_pagetable, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X); uvmmap(user_kernel_pagetable, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W); uvmmap(user_kernel_pagetable, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X); return user_kernel_pagetable; } 将procinit函数中在为每个进程在内核页表中分配内核栈的操作转移到allocproc函数中，需要注意的是我们需要在当前进程的kernel_pagetable分配内核栈，为此我们需要设置一个uvmmap函数，指明在哪个页表添加，参考kvmmap函数 // kernel/proc.c void procinit(void) { struct proc *p; initlock(\u0026pid_lock, \"nextpid\"); for(p = proc; p \u003c \u0026proc[NPROC]; p++) { initlock(\u0026p-\u003elock, \"proc\"); // Allocate a page for the process's kernel stack. // Map it high in memory, followed by an invalid // guard page. // char *pa = kalloc(); // if(pa == 0) // panic(\"kalloc\"); // uint64 va = KSTACK((int) (p - proc)); // kvmmap(va, (uint64)pa, PGSIZE, PTE_R | PTE_W); // p-\u003ekstack = va; } kvminithart(); } // kernel/proc.c static struct proc* allocproc(void) { ... p-\u003epagetable = proc_pagetable(p); p-\u003ekernel_pagetable = kvmcreate(); if(p-\u003epagetable == 0){ freeproc(p); release(\u0026p-\u003elock); return 0; } char *pa = kalloc(); if(pa == 0) panic(\"kalloc\"); uint64 va = KSTACK((int) (p - proc)); uvmmap(p-\u003ekernel_pagetable, va, (uint64)pa, PGSIZE, PTE_R | PTE_W); p-\u003ekstack = va; ... } // kernel/vm.c void uvmmap(pagetable_t pagetable, uint64 va, uint64 pa, uint64 sz, int perm) { if(mappages(pagetable, va, sz, pa, perm) != 0) panic(\"uvmmap\"); } 修改schduler函数，将该进程的内核页表kernel_pagetable装载进satp寄存器执行 // kernel/proc.c ... w_satp(MAKE_SATP(p-\u003ekernel_pagetable)); sfence_vma(); swtch(\u0026c-\u003econtext, \u0026p-\u003econtext); ... 实现释放进程内核页表函数freewalk_kernel_pagetable函数，参考freewalk函数，需要注意的是，每个进程的内核页表都映射了整个物理内存和进程本身的内核栈，内核栈单独free，我们需要避免free最低一级页表对应的物理块。（需要在kernel/defs.h中声明） // kernel/vm.c void freewalk_kernel_pagetable(pagetable_t pagetable) { for(int i = 0; i \u003c 512; i++){ pte_t pte = pagetable[i]; if((pte \u0026 PTE_V)){ pagetable[i] = 0; //只要最低一级页表项中这些标志位可能非0 if ((pte \u0026 (PTE_R|PTE_W|PTE_X)) == 0) { uint64 child = PTE2PA(pte); freewalk_kernel_pagetable((pagetable_t)child); } } } kfree((void*)pagetable); } 在freeproc函数中调用释放进程内核页表freewalk_kernel_pagetable函数 // kernel/proc.c if(p-\u003ekernel_pagetable) { freewalk_kernel_pagetable(p-\u003ekernel_pagetable); } 我们还需要修改kvmpa函数，将kernel_pagetable换成当前进程的内核页表。该函数将栈上虚拟地址转化为物理地址 // kernel/vm.c uint64 kvmpa(uint64 va) { uint64 off = va % PGSIZE; pte_t *pte; uint64 pa; pte = walk(myproc()-\u003ekernel_pagetable, va, 0); if(pte == 0) panic(\"kvmpa\"); if((*pte \u0026 PTE_V) == 0) panic(\"kvmpa\"); pa = PTE2PA(*pte); return pa+off; } ","date":"2022-10-30","objectID":"/mit-6.s081-lab3-pgtbl/:2:2","tags":["操作系统"],"title":"MIT 6.S081 Lab3 Pgtbl","uri":"/mit-6.s081-lab3-pgtbl/"},{"categories":["6.S081"],"content":"Simplify copyin/copyinstr（hard） 为了避免通过遍历进程页表来获取物理地址，我们需要将用户空间的映射添加到该进程的内核页表中。从而使得copyin和copyinstr可以直接操作用户指针。由于内核的虚拟内存从0开始的底部有一块空闲的地址，我们可以将映射添加到该部分，需要注意的是用户进程的最大大小限制为小于内核的最低虚拟地址。即0xC000000，PLIC寄存器的地址。 实现u2kvmcopy函数，将进程的页表复制到进程的内核页表中，需要注意的是我们需要将用户页表中的PTE_U标志位去掉，以便可以在内核中执行。参考uvmcopy函数 // kernel/vm.c void u2kvmcopy(pagetable_t pagetable, pagetable_t kernelpt, uint64 oldsz, uint64 newsz){ pte_t *pte_from, *pte_to; oldsz = PGROUNDUP(oldsz); for (uint64 i = oldsz; i \u003c newsz; i += PGSIZE){ if((pte_from = walk(pagetable, i, 0)) == 0) panic(\"u2kvmcopy: pte does not exist\"); if((pte_to = walk(kernelpt, i, 1)) == 0) panic(\"u2kvmcopy: pte walk failed\"); uint64 pa = PTE2PA(*pte_from); uint flags = (PTE_FLAGS(*pte_from)) \u0026 (~PTE_U); *pte_to = PA2PTE(pa) | flags; } } 在fork函数，exec函数和sbrk函数中添加对u2kvmcopy函数的调用，确保用户映射能够复制到进程的内核页表中。 // kernel/exec.c int exec(char *path, char **argv) { ... stackbase = sp - PGSIZE; u2kvmcopy(pagetable, p-\u003ekernel_pagetable, 0, sz); ... } // kernel/proc.c int fork(void) { ... u2kvmcopy(np-\u003epagetable, np-\u003ekernel_pagetable, 0, np-\u003esz); // copy saved user registers. *(np-\u003etrapframe) = *(p-\u003etrapframe); ... } // kernel/proc.c int growproc(int n) { ... if((sz = uvmalloc(p-\u003epagetable, sz, sz + n)) == 0) { return -1; } u2kvmcopy(p-\u003epagetable, p-\u003ekernel_pagetable, sz - n, sz); ... } 在userinit函数中将第一个进程的用户页表添加进该进程的内核页表。 // kernel/proc.c void userinit(void) { ... p-\u003esz = PGSIZE; u2kvmcopy(p-\u003epagetable, p-\u003ekernel_pagetable, 0, p-\u003esz); ... } 替换copyin和copyinstr（需要将copyin_new和copyinstr_new添加进kernel/defs.h）。 // kernel/vm.c int copyin(pagetable_t pagetable, char *dst, uint64 srcva, uint64 len) { return copyin_new(pagetable, dst, srcva, len); } int copyinstr(pagetable_t pagetable, char *dst, uint64 srcva, uint64 max) { return copyinstr_new(pagetable, dst, srcva, max); } 为了确保用户进程的最大大小限制为小于内核的最低虚拟地址，需要在sbrk加入限制 // kernel/proc.c int growproc(int n) { ... if(n \u003e 0){ if (PGROUNDUP(sz + n) \u003e= PLIC){ return -1; } ... } ... } ","date":"2022-10-30","objectID":"/mit-6.s081-lab3-pgtbl/:2:3","tags":["操作系统"],"title":"MIT 6.S081 Lab3 Pgtbl","uri":"/mit-6.s081-lab3-pgtbl/"},{"categories":["6.S081"],"content":"MIT 6.S801实验2","date":"2022-10-15","objectID":"/mit-6.s081-lab2-syscall/","tags":["操作系统"],"title":"MIT 6.S081 Lab2 Syscall","uri":"/mit-6.s081-lab2-syscall/"},{"categories":["6.S081"],"content":"课程知识 ","date":"2022-10-15","objectID":"/mit-6.s081-lab2-syscall/:1:0","tags":["操作系统"],"title":"MIT 6.S081 Lab2 Syscall","uri":"/mit-6.s081-lab2-syscall/"},{"categories":["6.S081"],"content":"什么是操作系统 操作系统是管理下层硬件资源，并为上层软件提供统一的抽象接口的软件。如果没有操作系统，进程可以直接运行在系统资源之上，甚至可以直接操作内存。操作系统可以保证系统资源的强隔离性，以实现多路复用和内存隔离。 具体来说，当我们用户空间有多个进程时，进程的调度需要靠进程自己释放和获得CPU资源，若出现崩溃则其他进程均无法运行。而有了操作系统，这些进程会被操作系统根据特定的调度算法进行执行，不会因为一个进程的崩溃而收到影响。 同样，用户程序可以直接对物理内存进行操作，进程可能会覆盖里一个进程的内存地址，导致程序崩溃。而有了操作系统，用户只需提供虚拟地址，OS会自动映射到物理地址进行操作，将和硬件的直接操作交给OS。 ","date":"2022-10-15","objectID":"/mit-6.s081-lab2-syscall/:1:1","tags":["操作系统"],"title":"MIT 6.S081 Lab2 Syscall","uri":"/mit-6.s081-lab2-syscall/"},{"categories":["6.S081"],"content":"用户态和内核态 用户空间的程序运行在用户态，内核空间的程序运行在内核态。用户态下CPU可运行普通权限的指令，内核态下CPU可运行特权指令，特权指令包括直接操纵硬件的指令和设置保护的指令，例如设置页表寄存器，关闭时钟中断等 处理器中有一个标志位，1表示用户态，0为内核态。从用户态到内核态的切换是通过ECALL来实现的，ECALL接受一个数字作为参数。调用ECALL指令，ECALL会跳转到内核一个特定的由内核控制的位置。syscall函数接收到ECALL的参数，会调用实际的系统调用。 #/user/usys.pl #usys.pl会被makefile调用，会被编译成usys.S汇编文件，当用户调用这些用户态程序时，便会进入usy.S执行 #可以看到用户态程序通过ecall指令跳转到内核，并且传入参数表示想要调用的系统调用 sub entry { my $name = shift; print \".global $name\\n\"; print \"${name}:\\n\"; print \" li a7, SYS_${name}\\n\"; print \" ecall\\n\"; print \" ret\\n\"; } #/user/usys.S #编译生成的fork()的汇编代码 #include \"kernel/syscall.h\" .global fork fork: li a7, SYS_fork ecall ret ECALL指令提升硬件特权级别，并将PC更改为内核定义的入口点，入口点的代码切换到内核栈，执行实现系统调用的内核指令，当系统调用完成时，内核切换回用户栈，并通过调用sret指令返回用户空间，该指令降低了硬件特权级别，并在系统调用指令刚结束时恢复执行用户指令。 每个进程有两个栈区，用户栈区和内核栈区，当进程执行用户指令时，只有它的用户栈在使用，它的内核栈是空的。当进程进入内核时，内核代码在进程的内核栈上执行，用户栈仍然包含保存的数据，只是不处于活动状态。 ","date":"2022-10-15","objectID":"/mit-6.s081-lab2-syscall/:1:2","tags":["操作系统"],"title":"MIT 6.S081 Lab2 Syscall","uri":"/mit-6.s081-lab2-syscall/"},{"categories":["6.S081"],"content":"宏内核和微内核 宏内核：整个操作系统的代码都运行在kernel mode中，集成度高，性能很好，缺点是内核很大，出现安全性问题的可能性也更大 微内核：微内核，内核只保留最基本的代码，如IPC，页表以及分时复用CPU等，大部分运行在用户空间。当我们需要调用这些系统调用时，通过内核作为中介进行调用。内核更安全，但是性能不行，需要两次内核空间到用户空间的切换。同时由于各部分隔离，共享page cache变得难以实现。 ","date":"2022-10-15","objectID":"/mit-6.s081-lab2-syscall/:1:3","tags":["操作系统"],"title":"MIT 6.S081 Lab2 Syscall","uri":"/mit-6.s081-lab2-syscall/"},{"categories":["6.S081"],"content":"xv6开机过程 计算机上电，初始化并运行一个存储在ROM的引导加载程序，引导加载程序将xv6内核加载到内存中(0x80000000) CPU从_entry(kernel/entry.S)开始运行xv6，_entry指令设置栈区，有了栈区，_entry调用C代码start start设置内核态，时钟编程产生计时器中断，设置返回地址为main函数地址，禁用虚拟内存。通过调用mert进入main函数 main()初始化设备页表，调用userinit()创建第一个用户进程，通过系统调用exec()重新进入内核，exec返回到init进程用户空间 init进程创建控制台，用文件描述符0，1，2打开控制台文件，并启动一个shell ","date":"2022-10-15","objectID":"/mit-6.s081-lab2-syscall/:1:4","tags":["操作系统"],"title":"MIT 6.S081 Lab2 Syscall","uri":"/mit-6.s081-lab2-syscall/"},{"categories":["6.S081"],"content":"xv6系统调用过程 用户程序调用系统调用函数，将系统调用号存入a7寄存器，调用ecall指令。 ecall指令会进入内核定义的入口点，切换内核栈运行，依次执行uservec、usertrap和syscall。 syscall会获取trapframe中存储在a7寄存器的值，即系统调用号，执行对应的系统调用函数。 处理结束之后需要将返回值放入trapframe的a0寄存器，调用sret，用户空间会获得系统调用的返回结果。 ","date":"2022-10-15","objectID":"/mit-6.s081-lab2-syscall/:1:5","tags":["操作系统"],"title":"MIT 6.S081 Lab2 Syscall","uri":"/mit-6.s081-lab2-syscall/"},{"categories":["6.S081"],"content":"实验内容 实验二和实验一相反，已经帮我们实现好了用户程序，需要涉及到内核的修改和扩展，要求我们实现系统调用，保证用户程序正常运行。 ","date":"2022-10-15","objectID":"/mit-6.s081-lab2-syscall/:2:0","tags":["操作系统"],"title":"MIT 6.S081 Lab2 Syscall","uri":"/mit-6.s081-lab2-syscall/"},{"categories":["6.S081"],"content":"System call tracing（moderate） system call tracing实验要求我们实现一个可以追踪调用情况的系统调用，我们需要创建一个sys_trace的系统调用，该系统接受一个mask参数，若mask第n位为1，即表示我们需要显示该系统调用被调用情况，打印出进程id、系统调用的名称和返回值。为此，我们需要在每次系统调用结束之后，检查该进程mask对应位上是否为1，即调用是否需要打印。 首先添加系统调用号 // kernel/syscall.h ... #define SYS_trace 22 在函数指针数组syscalls[]中加入sys_trace // kernel/syscall.c static uint64 (*syscalls[])(void) = { ... [SYS_trace] sys_trace, } 在进程结构体中添加mask属性，保存需要追踪的系统调用 // kernel/proc.h struct proc { ... int mask; } 修改fork(),确保派生的任何子进程也能进行追踪 // kernel/proc.c int fork(void) { ... np-\u003emask = p-\u003emask; release(\u0026np-\u003elock); return pid; } 实现sys_trace() // kernel/sysproc.c uint64 sys_trace(void) { int n; struct proc *p = myproc(); if(argint(0, \u0026n) \u003c 0) return -1; p-\u003emask = n; return 0; } 修改syscall(void) // kernel/syscall.c //保存系统调用的名称，便于打印 static char* names[23] = { \"fork\", \"exit\", \"wait\", \"pipe\", \"read\", \"kill\",\"exec\", \"fstat\", \"chdir\", \"dup\", \"getpid\", \"sbrk\", \"sleep\", \"uptime\", \"open\", \"write\", \"mknod\", \"unlink\", \"link\", \"mkdir\", \"close\", \"trace\", \"sysinfo\" }; void syscall(void) { int num; struct proc *p = myproc(); num = p-\u003etrapframe-\u003ea7; if(num \u003e 0 \u0026\u0026 num \u003c NELEM(syscalls) \u0026\u0026 syscalls[num]) { p-\u003etrapframe-\u003ea0 = syscalls[num](); if(p-\u003emask \u003e\u003e num \u0026 1) printf(\"%d: syscall %s -\u003e %d\\n\", p-\u003epid, names[num - 1], p-\u003etrapframe-\u003ea0); } else { printf(\"%d %s: unknown sys call %d\\n\", p-\u003epid, p-\u003ename, num); p-\u003etrapframe-\u003ea0 = -1; } } ","date":"2022-10-15","objectID":"/mit-6.s081-lab2-syscall/:2:1","tags":["操作系统"],"title":"MIT 6.S081 Lab2 Syscall","uri":"/mit-6.s081-lab2-syscall/"},{"categories":["6.S081"],"content":"Sysinfo（moderate） sysinfo实验要求我们实现显示运行信息的系统调用，包括显示空闲内存的字节数和进程数。空闲内存的字节数的统计参考kalloc.c，进程数的统计参考proc.c 首先添加系统调用号 // kernel/syscall.h ... #define SYS_sysinfo 23 在函数指针数组syscalls[]中加入sys_trace // kernel/syscall.c static uint64 (*syscalls[])(void) = { ... [SYS_sysinfo] sys_sysinfo, } 统计空闲内存的字节数（需要在kernel/defs.h中声明） // kernel/kalloc.c int freecount(void) { int freecnt = 0; struct run *r; r = kmem.freelist; while(r) { freecnt++; r = r-\u003enext; } return freecnt * PGSIZE; } 统计进程数（需要在kernel/defs.h中声明） // kernel/proc.c int proccount(void) { int proccnt = 0; struct proc *p; for(p = proc; p \u003c \u0026proc[NPROC]; p++) { if(p-\u003estate != UNUSED) { proccnt++; } } return proccnt; } 实现sys_info() uint64 sys_sysinfo(void) { uint64 addr; struct sysinfo si; if(argaddr(0, \u0026addr) \u003c 0) return -1; si.freemem = freecount(); si.nproc = proccount(); //将sysinfo结构体复制回用户空间 if(copyout(myproc()-\u003epagetable, addr, (char *)\u0026si, sizeof(si)) \u003c 0) return -1; return 0; } ","date":"2022-10-15","objectID":"/mit-6.s081-lab2-syscall/:2:2","tags":["操作系统"],"title":"MIT 6.S081 Lab2 Syscall","uri":"/mit-6.s081-lab2-syscall/"},{"categories":["6.S081"],"content":"MIT 6.S801 实验1","date":"2022-10-11","objectID":"/mit-6.s081-lab1-util/","tags":["操作系统"],"title":"MIT 6.S081 Lab1 Util","uri":"/mit-6.s081-lab1-util/"},{"categories":["6.S081"],"content":"6.S081是MIT开放的操作系统课程，围绕xv6展开教学和实验。xv6是简化的类UNIX系统，采用精简指令集RISC-V架构，运行在RISC-V微处理器上，实验可以在QEMU上模拟运行，QEMU是一个硬件模拟器，用来模拟CPU和计算机，可以虚拟不同的硬件平台架构，在没有特定RISC-V硬件下也能运行xv6。本实验是基于6.S081 / Fall 2020。 ","date":"2022-10-11","objectID":"/mit-6.s081-lab1-util/:0:0","tags":["操作系统"],"title":"MIT 6.S081 Lab1 Util","uri":"/mit-6.s081-lab1-util/"},{"categories":["6.S081"],"content":"课程知识 ","date":"2022-10-11","objectID":"/mit-6.s081-lab1-util/:1:0","tags":["操作系统"],"title":"MIT 6.S081 Lab1 Util","uri":"/mit-6.s081-lab1-util/"},{"categories":["6.S081"],"content":"内核的概念 内核提供操作系统的基本功能，在开机时被加载进内存并常驻内存。内核不是进程，就是一段代码加数据的二进制文件。可以看成是一组系统调用的集合，不能主动执行，只能通过系统调用来为其他程序提供服务。例如用户要执行系统调用open()打开一个文件，就会由用户态切换为内核态，执行内核提供的sys_open()打开文件，返回fd。 内核组成： 管理用户进程的数据结构，如进程结构体，页表 管理各种硬件资源的数据结构，如抽象出的磁盘，I/O设备 各个模块提供的系统调用，如内存模块，文件系统，进程间通信(IPC) ","date":"2022-10-11","objectID":"/mit-6.s081-lab1-util/:1:1","tags":["操作系统"],"title":"MIT 6.S081 Lab1 Util","uri":"/mit-6.s081-lab1-util/"},{"categories":["6.S081"],"content":"xv6的进程表示 Xv6进程由用户空间和内核空间组成，用户空间包含指令，数据和堆栈，内核空间包含每个进程状态。Xv6采用分时机制，保证多个进程并发执行。当一个进程没有执行时，Xv6保存CPU寄存器，并在下一次运行该进程时恢复它们。 // kernel/proc.h // Xv6进程结构体表示 struct proc { struct spinlock lock; // p-\u003elock must be held when using these: enum procstate state; // Process state struct proc *parent; // Parent process void *chan; // If non-zero, sleeping on chan int killed; // If non-zero, have been killed int xstate; // Exit status to be returned to parent's wait int pid; // Process ID // these are private to the process, so p-\u003elock need not be held. uint64 kstack; // Virtual address of kernel stack uint64 sz; // Size of process memory (bytes) pagetable_t pagetable; // User page table struct trapframe *trapframe; // data page for trampoline.S struct context context; // 进程上下文，即寄存器内容 struct file *ofile[NOFILE]; // Open files struct inode *cwd; // Current directory char name[16]; // Process name (debugging) }; ","date":"2022-10-11","objectID":"/mit-6.s081-lab1-util/:1:2","tags":["操作系统"],"title":"MIT 6.S081 Lab1 Util","uri":"/mit-6.s081-lab1-util/"},{"categories":["6.S081"],"content":"常见的系统调用 fork() 一个进程可以使用fork系统调用创建一个新进程，子进程和父进程内存完全相同，在父进程中返回子进程的pid，在子进程中返回0,我们可以根据fork()返回值判断父子进程。子进程返回0，父进程返回子进程的pid。详见kernel/proc.c。 wait() 用来回收所有的子进程。wait()系统调用返回当前进程已退出子进程的PID，并将子进程的退出状态复制到传递给wait的地址, 0表示成功， 1表示失败，wait()会一直等待到子进程退出，若没有子进程，返回-1。如果我们由n个子进程，若想要等待所有的子进程都退出，父进程需要调用n次fork()。详见kernel/wait.c。 exec() 从文件系统中加载ELF格式的内存映像替换调用进程的内存，包含两个参数：文件名和字符串数组。exec()执行成功，它不向调用进程返回数据，而是使指令从ELF header中声明的程序入口开始执行，exec()一般配合fork()使用。详见kernel/exec.c。 ","date":"2022-10-11","objectID":"/mit-6.s081-lab1-util/:1:3","tags":["操作系统"],"title":"MIT 6.S081 Lab1 Util","uri":"/mit-6.s081-lab1-util/"},{"categories":["6.S081"],"content":"文件描述符 进程需要读写由内核管理的对象，包括文件，管道，设备等，文件描述符将这些对象之间的差异抽象出来，隐藏不同类型文件之间的差异，使用文件描述符统一进行I/O。举个例子，cat程序并不需要知道是从文件，管道还是设备读取，也不需要知道写入到控制台、文件还是设备。 每个进程都有一个从文件描述符表，默认0表示标准输入，1表示标准输出，2表示标准错误，每次打开一个新文件，**优先分配最小的未使用的文件描述符，**可以实现I/O重定向。 引用文件的每个文件描述符都有一个与之关联的偏移量，read每次从文件的偏移量开始读取数据，write类似，exec()会替换调用进程的内存，但是不会改变修改子进程的描述符，并且偏移量在父文件和子文件是共享的。 ","date":"2022-10-11","objectID":"/mit-6.s081-lab1-util/:1:4","tags":["操作系统"],"title":"MIT 6.S081 Lab1 Util","uri":"/mit-6.s081-lab1-util/"},{"categories":["6.S081"],"content":"管道 管道本质是一段内核缓冲区，一端用于读，一端用于写，可以作为一种进程间通信方式， p[0]负责读，p[1]负责写。 当读取端或写入端有多个文件描述符指向的时候。read会等待直到有新数据写入或者所有指向写入端的文件描述符都被关闭， write会等待直到有数据读出或者所有指向读取端的文件描述符都被关闭。 当管道的读端和写端没有指向的文件描述符时，管道会自动回收。同时相比于文件重定向，管道可以任意传递长的数据流，允许并行执行，且在进程间通讯时读写效率更高。 ","date":"2022-10-11","objectID":"/mit-6.s081-lab1-util/:1:5","tags":["操作系统"],"title":"MIT 6.S081 Lab1 Util","uri":"/mit-6.s081-lab1-util/"},{"categories":["6.S081"],"content":"实验内容 实验一并没有设计内核的修改和扩展，只是在用户空间利用xv6提供的系统调用完成一些公共程序。我们在接下来的实验中会用到以下系统调用： 系统调用 描述 int fork() 创建一个进程，父进程返回子进程PID，子进程返回0 int exit(int status) 终止当前进程，并将status报告给wait()函数，无返回 int wait(int *status) 等待一个子进程退出，status保存退出状态，返回子进程PID int getpid() 返回当前进程的PID int exec(char *file, char *argv[]) 加载一个文件并使用参数执行 int open(char* file, int flags) 打开一个文件，flags表示读/写，返回一个fd int close(int fd) 释放打开的文件fd int write(int fd, char *buf, int n) 从buf中写入n个字节到文件描述符fd， 返回n int read(int fd, char *buf, int n) 从fd中读取n个字节到buf中，返回读取的字节数 int pipe(int p[]) 创建一个管道，把读写文件描述符放在p[0]和p[1]中 int fstat(int fd, struct stat *st) 将打开文件fd的信息存入stat结构体中 int sleep(int n) 使CPU休眠n个节拍 ","date":"2022-10-11","objectID":"/mit-6.s081-lab1-util/:2:0","tags":["操作系统"],"title":"MIT 6.S081 Lab1 Util","uri":"/mit-6.s081-lab1-util/"},{"categories":["6.S081"],"content":"sleep (easy） sleep实验我们只需要xv6提供的int sleep(int)系统调用即可。 int main(int argc, char *argv[]) { if(argc \u003c 2) { fprintf(2, \"Usage: sleep number\\n\"); exit(1); } int n = atoi(argv[1]); sleep(n); exit(0); } ","date":"2022-10-11","objectID":"/mit-6.s081-lab1-util/:2:1","tags":["操作系统"],"title":"MIT 6.S081 Lab1 Util","uri":"/mit-6.s081-lab1-util/"},{"categories":["6.S081"],"content":"pingpong (easy) pingpong实验使用管道进行父子进程的通信。实验需要使用两个管道，分别负责父进程的发送和子进程的发送，需要注意阻塞问题，当使用fork()之后，父子进程的p[0]都指向读取端，p[1]均指向写入端。为此我们需要将多余的fd关闭，保证管道能被回收。 int main(int agrc, char *argv[]) { int pid; int p2c[2], c2p[2]; char buf[5]; pipe(p2c); pipe(c2p); pid = fork(); if(pid == 0) { close(p2c[1]); read(p2c[0], buf, 5); fprintf(2, \"%d: received %s\\n\", getpid(), buf); close(p2c[0]); close(c2p[0]); write(c2p[1], \"pong\", 5); close(c2p[1]); exit(0); } else { close(p2c[0]); write(p2c[1], \"ping\", 5); close(p2c[1]); close(c2p[1]); read(c2p[0], buf, 5); fprintf(2, \"%d: received %s\\n\", getpid(), buf); close(c2p[0]); wait((int *)0); } exit(0); } ","date":"2022-10-11","objectID":"/mit-6.s081-lab1-util/:2:2","tags":["操作系统"],"title":"MIT 6.S081 Lab1 Util","uri":"/mit-6.s081-lab1-util/"},{"categories":["6.S081"],"content":"primes (moderate)/(hard)) primes实验是一个有趣的利用父子进程求解素数问题。利用埃拉托色尼筛，父进程首先将2 ~35的素数放入管道中，fork()出子进程，读取管道中第一个数k，该数为素数，打印该数。并将管道中剩余的数全部取出，去掉k的倍数，剩余数存入管道，交给下一个子进程进行处理。直至管道为空。需要注意关闭没用的fd。 void primes(int *p) { int i, k, pid; int np[2]; if(read(p[0], \u0026k, 4) == 0) { close(p[0]); exit(0); } fprintf(2, \"prime %d\\n\", k); pipe(np); pid = fork(); if(pid == 0) { close(np[1]); primes(np); } else { close(p[1]); close(np[0]); while(read(p[0], \u0026i, 4) != 0) { if(i % k != 0) { write(np[1], \u0026i, 4); } } close(np[1]); close(p[0]); wait((int*)0); exit(0); } } int main(int argc, char *argv[]) { int i, pid; int p[2]; pipe(p); pid = fork(); if(pid == 0) { close(p[1]); primes(p); } else { close(p[0]); for(i = 2; i \u003c= 35; i++) { write(p[1], \u0026i, sizeof(int)); } close(p[1]); wait((int *)0); } exit(0); } ","date":"2022-10-11","objectID":"/mit-6.s081-lab1-util/:2:3","tags":["操作系统"],"title":"MIT 6.S081 Lab1 Util","uri":"/mit-6.s081-lab1-util/"},{"categories":["6.S081"],"content":"find (moderate) find实验用来查找当前路径下所有指定文件名的文件，需要返回文件全路径，参考user/ls.c中关于目录文件的读取，即可实现。 //获取不带路径的文件名 char* fmtname(char *path) { static char buf[DIRSIZ+1]; char *p; for(p=path+strlen(path); p \u003e= path \u0026\u0026 *p != '/'; p--) ; p++; if(strlen(p) \u003e= DIRSIZ) return p; memmove(buf, p, strlen(p)); *(buf + strlen(p))= 0; return buf; } void find(char* path, const char* filename) { char buf[512], *p; int fd; struct dirent de; struct stat st; if((fd = open(path, 0)) \u003c 0) { fprintf(2, \"find: cannot open %s\\n\", path); return; } if(fstat(fd, \u0026st) \u003c 0){ fprintf(2, \"find: cannot stat %s\\n\", path); close(fd); return; } switch(st.type){ case T_FILE: if(strcmp(fmtname(path), filename) == 0) { printf(\"%s\\n\", path); } break; case T_DIR: if(strlen(path) + 1 + DIRSIZ + 1 \u003e sizeof buf){ printf(\"ls: path too long\\n\"); break; } strcpy(buf, path); p = buf+strlen(buf); *p++ = '/'; while(read(fd, \u0026de, sizeof(de)) == sizeof(de)){ if(de.inum == 0 || strcmp(de.name, \".\") == 0 || strcmp(de.name, \"..\") == 0) continue; memmove(p, de.name, DIRSIZ); p[DIRSIZ] = 0; find(buf, filename); } break; } close(fd); } int main(int argc, char *argv[]) { if(argc \u003c 2) { fprintf(2, \"Usage: find path filename\\n\"); exit(1); } else if(argc == 2) { find(\".\", argv[1]); } else { find(argv[1], argv[2]); } exit(0); } ","date":"2022-10-11","objectID":"/mit-6.s081-lab1-util/:2:4","tags":["操作系统"],"title":"MIT 6.S081 Lab1 Util","uri":"/mit-6.s081-lab1-util/"},{"categories":["6.S081"],"content":"xargs (moderate) xargs实验是编写一个简化版UNIX的xargs程序。xargs命令的作用，是将标准输入转为命令行参数，需要配合管道使用。实现xargs首先需要读取标准输入中的字符串，并将字符串添加到xargs所要执行的程序参数列表最后作为参数。若读取到多行， 需要为每一行的都fork()一个子进程进行执行。 int main(int argc, char *argv[]) { int i; char *p, buf[512]; if(argc \u003c 2) { fprintf(2, \"Usage: xargs command args...\\n\"); exit(1); } if(read(0, buf, sizeof(buf)) == 0) { fprintf(2, \"no arguments\\n\"); exit(1); } p = buf; for(i = 0; buf[i] != 0; i++) { if(buf[i] == '\\n') { buf[i] = 0; if(fork() == 0) { argv[argc++] = p; argv[argc] = 0; exec(argv[1], argv + 1); exit(0); } else { p = buf + i + 1; wait((int *)0); } } } exit(0); } ","date":"2022-10-11","objectID":"/mit-6.s081-lab1-util/:2:5","tags":["操作系统"],"title":"MIT 6.S081 Lab1 Util","uri":"/mit-6.s081-lab1-util/"},{"categories":["leetcode"],"content":"Acwing算法基础课模板","date":"2021-07-10","objectID":"/algorithm_template/","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"Acwing算法基础课模板 ","date":"2021-07-10","objectID":"/algorithm_template/:0:0","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"排序 ","date":"2021-07-10","objectID":"/algorithm_template/:1:0","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"快速排序 void quick_sort(int q[], int l, int r) { if (l \u003e= r) return; int i = l - 1, j = r + 1, x = q[ l + r \u003e\u003e 1 ]; while(i \u003c j) { do i++ ; while(q[i] \u003c x); do j-- ; while(q[j] \u003e x); if(i \u003c j) swap(q[i],q[j]); } quick_sort(q, l, j); //只会出现i == j 或者 i = j + 1 情况 quick_sort(q, j+1, r); } ","date":"2021-07-10","objectID":"/algorithm_template/:1:1","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"归并排序 void merge_sort(int a[], int l, int r) { if(l\u003e=r) return; int mid = l+r \u003e\u003e 1; merge_sort(a,l,mid); merge_sort(a,mid+1,r); int k = 0, i = l, j = mid+1; while(i \u003c= mid \u0026\u0026 j \u003c= r) { if(a[i] \u003c= a[j]) tmp[k++] = a[i++]; else tmp[k++] = a[j++]; } while(i \u003c= mid) tmp[k++] = a[i++]; while(j \u003c= r) tmp[k++] = a[j++]; for(i = l, j = 0; i \u003c= r; i++, j++) a[i] = tmp[j]; } ","date":"2021-07-10","objectID":"/algorithm_template/:1:2","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"二分 ","date":"2021-07-10","objectID":"/algorithm_template/:2:0","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"整数二分 //先写check函数，想一下check如何更新更新区间，如果l = mid, 需要+1 int bsearch_1(int l, int r) { while(l \u003c r) { int mid = l+r \u003e\u003e 1; if(check(mid)) r = mid; else l = mid + 1; } return l; } int bsearch_2(int l, int r) { //区别在于当l = mid, 需要+1 while(l \u003c r) { int mid = l + r + 1 \u003e\u003e 1; if(check(mid)) l = mid; else r = mid - 1; } return l; } ","date":"2021-07-10","objectID":"/algorithm_template/:2:1","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"浮点数二分 double bsearch_3(double l, double r) { //eps 尽量比题目要求再高出两位，减少误差 while(r-l \u003e eps) { double mid = (l + r) / 2; if(check(mid)) r = mid; else l = mid; } return l; } ","date":"2021-07-10","objectID":"/algorithm_template/:2:2","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"高精度 ","date":"2021-07-10","objectID":"/algorithm_template/:3:0","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"高精度加法 vector\u003cint\u003e add(vector\u003cint\u003e\u0026 a, vector\u003cint\u003e\u0026 b) { vector\u003cint\u003e c; int t = 0; for(int i = 0; i \u003c a.size() || i \u003c b.size(); i++) { if(i \u003c a.size()) t += a[i]; if(i \u003c b.size()) t += b[i]; c.push_back(t % 10); t /= 10; } if(t) c.push_back(t); return c; } ","date":"2021-07-10","objectID":"/algorithm_template/:3:1","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"高精度减法 vector\u003cint\u003e sub(vector\u003cint\u003e \u0026A, vector\u003cint\u003e \u0026B) { vector\u003cint\u003e C; for (int i = 0, t = 0; i \u003c A.size(); i ++ ) { t = A[i] - t; if (i \u003c B.size()) t -= B[i]; C.push_back((t + 10) % 10); if (t \u003c 0) t = 1; else t = 0; } while (C.size() \u003e 1 \u0026\u0026 C.back() == 0) C.pop_back(); //去除前导0 return C; } ","date":"2021-07-10","objectID":"/algorithm_template/:3:2","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"高精度乘法 vector\u003cint\u003e mul(vector\u003cint\u003e \u0026A, int b) { vector\u003cint\u003e C; int t = 0; for (int i = 0; i \u003c A.size() || t; i ++ ) { if (i \u003c A.size()) t += A[i] * b; C.push_back(t % 10); t /= 10; } while (C.size() \u003e 1 \u0026\u0026 C.back() == 0) C.pop_back(); return C; } ","date":"2021-07-10","objectID":"/algorithm_template/:3:3","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"高精度除法 vector\u003cint\u003e div(vector\u003cint\u003e\u0026 A, int B, int\u0026 r) { vector\u003cint\u003e c; r = 0; //从最高位算 for(int i = A.size() - 1; i \u003e= 0 ;i--) { r = r * 10 + A[i]; c.push_back(r / B); r %= B; } reverse(c.begin(), c.end()); while(c.size() \u003e 1 \u0026\u0026 c.back() == 0) c.pop_back(); return c; } ","date":"2021-07-10","objectID":"/algorithm_template/:3:4","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"差分和前缀和 ","date":"2021-07-10","objectID":"/algorithm_template/:4:0","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"前缀和 //构造二维前缀和 s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i][j]; //获取二维前缀和 s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1]; ","date":"2021-07-10","objectID":"/algorithm_template/:4:1","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"差分 // a[i] = b[1] + b[2] + ... + b[i] void insert(int l, int r, int c) { a[l] += c; a[r + 1] -= c; } // 二维差分 void insert(int x1, int y1, int x2, int y2, int c) { a[x1][y1] += c; a[x2 + 1][y1] -= c; a[x1][y2 + 1] -= c; a[x2 + 1][y2 + 1] += c; } b[i][j] = b[i][j] + b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1]; ","date":"2021-07-10","objectID":"/algorithm_template/:4:2","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"双指针 //需要找到一些性质(单调性) 使得O(n^2)变为O(n) for(int i = 0, j = 0; i \u003c n; i++) { while(j \u003c i \u0026\u0026 check(i, j)) j++; } ","date":"2021-07-10","objectID":"/algorithm_template/:5:0","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"位运算 求第k位 n \u003e\u003e k \u0026 1; 返回最后一位1的位置 lowbit(n) n \u0026 -n ; ","date":"2021-07-10","objectID":"/algorithm_template/:6:0","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"离散化 //区间和 vector\u003cint\u003e alls; //存储所有离散化的值 sort(alls.begin(), alls.end()); //排序 alls.erase(unique(alls.begin(), alls.end()), alls.end()); //去重 int find(x) { int l = 0, r = alls.size() - 1; while(l \u003c r) { int mid = (l + r) \u003e\u003e 1; if(alls[mid] \u003e= x) r = mid; else l = mid + 1; } return r + 1; //便于求前缀和 } ","date":"2021-07-10","objectID":"/algorithm_template/:7:0","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"区间合并 void merge(vector\u003cpii\u003e \u0026segs) { vector\u003cpii\u003e res; sort(segs.begin(), segs.end()); int st = -2e9, ed = -2e9; for(auto seg : segs) { if(ed \u003c seg.first) { if(st != -2e9) res.push_back({st, ed}); st = seg.first, ed = seg.second; } else ed = max(ed, seg.second); } if(st != -2e9) res.push_back({st,ed}); segs = res; } ","date":"2021-07-10","objectID":"/algorithm_template/:8:0","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"数据结构 ","date":"2021-07-10","objectID":"/algorithm_template/:9:0","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"单链表 //主要应用 邻接表，存储图和树 int head, e[N], ne[N], idx; void init() { head = -1, idx = 0; } void add_to_head(int x) { e[idx] = x, ne[idx] = head, head = idx, idx ++; } //在下标为k的节点后添加 void add(int k, int x) { e[idx] = x, ne[idx] = ne[k], ne[k] = idx, idx ++; } //在下标为k的节点后删除 void remove(int k) { ne[k] = ne[ne[k]]; } ","date":"2021-07-10","objectID":"/algorithm_template/:9:1","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"双链表 //l[i] 节点i左边的点是 r[i] 节点i右边的点是 int e[N], l[N], r[N], idx; void init() { r[0] = 1, l[1] = 0; idx = 2; } //在下标为k的节点右边插入 void add(int k, int x) { e[idx] = x; r[idx] = r[k]; l[idx] = k; l[r[k]] = idx; r[k] = idx; idx ++; } //在下标为k的节点左边插入 void add(int l[k], int x); //删除下标为k的节点 void remove(int k) { l[r[k]] = l[k]; r[l[k]] = r[k]; } ","date":"2021-07-10","objectID":"/algorithm_template/:9:2","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"栈 //tt表示栈顶 int stk[N], tt; //插入 stk[++tt] = x; //弹出 tt--; //栈顶的值 stk[tt]; //判断栈是否为空 if(tt \u003e 0) {}; ","date":"2021-07-10","objectID":"/algorithm_template/:9:3","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"队列 int q[N], hh = 0, tt = -1; //插入 q[++tt] = x; //弹出 hh++ //判空 if(hh \u003c= tt) not empty //取出队头元素 q[hh]; ","date":"2021-07-10","objectID":"/algorithm_template/:9:4","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"单调栈 //常见模型：找出每个数左边离它最近的比它大/小的数 int tt = 0; for(int i = 0; i \u003c n; i++) { while(tt \u0026\u0026 stk[tt] \u003e= x) tt--; if(tt) {} else {} stk[++tt] = x; } ","date":"2021-07-10","objectID":"/algorithm_template/:9:5","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"单调队列 //常见模型：求出滑动窗口的最大值/最小值 int hh = 0, tt = -1; for(int i = 0; i \u003c n; i++) { while(hh \u003c= tt \u0026\u0026 q[hh] \u003c i - k + 1) hh++; //判断队头是否滑出窗口 while(hh \u003c= tt \u0026\u0026 a[q[tt]] \u003e= a[i]) tt--; q[++tt] = i; } ","date":"2021-07-10","objectID":"/algorithm_template/:9:6","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"KMP //求next的过程 for(int i = 2, j = 0; i \u003c= n; i++) { while(j \u0026\u0026 p[i] != p[j + 1]) j = next[j]; if(p[i] == p[j + 1]) j++; next[i] = j; } //匹配过程 for(int i = 1, j = 0; i \u003c= m; i++) { //j 总往前错一位 while(j \u0026\u0026 s[i] != p[j + 1]) j = next[j]; if(s[i] == p[j + 1]) j++; if(j==m) { //匹配成功后的逻辑 } } ","date":"2021-07-10","objectID":"/algorithm_template/:9:7","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"Trie数 int son[N][26], cnt[N], idx; // 0号点既是根节点，又是空节点 // son[][]存储树中每个节点的子节点 // cnt[]存储以每个节点结尾的单词数量 void insert(char* str) { int p = 0; for(int i = 0; str[i]; i++) { int u = str[i] - 'a'; if(!son[p][u]) son[p][u] = ++idx; p = son[p][u]; } cnt[p]++; } int query(char *str) { int p = 0; for(int i = 0; str[i]; i++) { int u = str[i] - 'a'; if(!son[p][u]) return 0; p = son[p][u]; } return cnt[p]; } ","date":"2021-07-10","objectID":"/algorithm_template/:9:8","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"并查集 //作用: //1.将两个集合合并 //2.询问两个元素是否在一个集合中 //朴素并查集 int p[N]; int find(int x) { if(p[x] != x) p[x] = find(p[x]); return p[x]; } //合并操作 p[find(a)] = find(b); //维护size的并查集 int p[N], size[N]; int find(int x) { if(p[x] != x) p[x] = find(p[x]); return p[x]; } //合并操作 size[find(b)] += size[find(a)]; p[find(a)] = find(b); ","date":"2021-07-10","objectID":"/algorithm_template/:9:9","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"堆 int h[N], size; for(int i = n/2; i; i--) down(i); //和左右孩子进行比较 void down(int u) { int t = u; if(t * 2 \u003c= size \u0026\u0026 h[t * 2] \u003c h[u]) t = u * 2; if(t * 2 + 1 \u003c= size \u0026\u0026 h[t * 2 + 1] \u003c h[u]) t = u * 2 + 1; if(t != u) { swap(h[t], h[u]); down(t); } } void up(int u) { while(u / 2 \u0026\u0026 h[u / 2] \u003e h[u]) { swap(h[u / 2], h[u]); u = u / 2; } } ","date":"2021-07-10","objectID":"/algorithm_template/:9:10","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"哈希表 //拉链法 int h[N], e[N], ne[N], idx; void insert(int x) { int k = (x % N + N) % N; e[idx] = x, ne[idx] = h[k], h[k] = idx++; } bool find(int x) { int k = (x % N + N) % N; for (int i = h[k]; i != -1; i = ne[i]) if (e[i] == x) return true; return false; } ","date":"2021-07-10","objectID":"/algorithm_template/:9:11","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"STL ","date":"2021-07-10","objectID":"/algorithm_template/:10:0","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"vector vector\u003cint\u003e a; //所有容器均有的操作 a.size(); a.empty(); a.clear(); front()/back(); push_back()/pop_back(); begin()/end(); 支持比较运算; ","date":"2021-07-10","objectID":"/algorithm_template/:10:1","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"pair pair\u003cint, int\u003e p; p = make_pair(123, 345)/p = {123, 345}; p.first/p.second; ","date":"2021-07-10","objectID":"/algorithm_template/:10:2","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"string clear(); sub_str(int startindex, int len); c_str() 返回字符数组的启示地址; ","date":"2021-07-10","objectID":"/algorithm_template/:10:3","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"queue push()/pop(); front()/back(); //清空 q = queue\u003cint\u003e(); ","date":"2021-07-10","objectID":"/algorithm_template/:10:4","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"priority_queue push()/pop(); top(); //默认是大根堆，实现小根堆 1.插入负数； 2.priority_queue\u003cint, vector\u003cint\u003e, greater\u003cint\u003e\u003e heap; ","date":"2021-07-10","objectID":"/algorithm_template/:10:5","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"stack push()/pop(); top(); ","date":"2021-07-10","objectID":"/algorithm_template/:10:6","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"deque //速度较慢 front()/back(); push_back()/pop_back(); push_front()/pop_front(); begin()/end(); ","date":"2021-07-10","objectID":"/algorithm_template/:10:7","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"set / multiset //set没有重复元素 multiset可以有 insert(); find();//不存在返回end迭代器 count(); //某个数个数 erase(); //可以删除所有数，也可以删除单个迭代器 lower_bound()/ upper_bound(); //返回 \u003e= x最小的数 / 返回 \u003e x最小的数 没有返回end() ","date":"2021-07-10","objectID":"/algorithm_template/:10:8","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"map / multimap insert(); erase(); find(); lower_bound()/ upper_bound(); ","date":"2021-07-10","objectID":"/algorithm_template/:10:9","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"unorder_set / unorder_multiset / unorder_map / unordered_multimap // 所有操作O(1) // 不支持lower_bound() upper_end(); being() end() ","date":"2021-07-10","objectID":"/algorithm_template/:10:10","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"bitset bitset\u003c10000\u003e b; ~ | \u0026 ^; \u003c\u003c \u003e\u003e; == !=; count(); any() //判读是否至少有一个1 none() //判断是否全为0 set(k, v) reset() //将所有数取反 flip() //取反 ","date":"2021-07-10","objectID":"/algorithm_template/:10:11","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"动态规划 无后效性，动态规划要求求解的子问题不受后续阶段的影响。换言之，动态规划对状态空间的遍历构成一张有向无环图，遍历该有向无环图就是一个拓扑序，有向无环图中每个节点对应不同的状态，图中的边对应状态之间的转移。 ","date":"2021-07-10","objectID":"/algorithm_template/:11:0","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"背包问题 01背包 //考虑前i个物品，且总体积不大于j的所有选法 int v[N], w[N]; int f[N][N]; for(int i = 1; i \u003c= n; i++) { for(int j = 0; j \u003c= m; j++) { f[i][j] = f[i - 1][j]; if(j \u003e= v[i]) f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]); } } //优化 int f[N]; for(int i = 1; i \u003c= n; i++) { for(int j = m; j \u003e= w[i]; j--) { f[j] = max(f[j], f[j - v[i]] + w[i]); } } 完全背包 for(int i = 1; i \u003c= n; i++) for(int j = 0; j \u003c= m; j++) for(int k = 0; k * v[i] \u003c= j; k++) f[i][j] = max(f[i][j], f[i - 1][j - k * v[i]] + k * w[i]) /*优化 f[i, j] = max(f[i - 1][j], f[i - 1][j - v] + w, f[i - 1][j - 2*v] + 2*w + .....) f[i, j -v] = max( f[i - 1][j - v], f[i - 1][j - 2* v]......) */ for(int i = 1; i \u003c= n; i++) for(int j = 0; j \u003c= m; j++) { f[i][j] = f[i - 1][j]; if(j \u003e= v[i]) f[i][j] = max(f[i][j], f[i][j - v[i]] + w[i]); } //优化(区别于01背包的遍历顺序) for(int i = 1; i \u003c= n; i++) { for(int j = v[i], j \u003c= m; j++) { f[j] = max(f[j], f[j - v[i]] + w[i]); } } 多重背包 //将多重背包转化为01背包(二进制优化) while(k \u003c= s) { cnt++; v[cnt] = a * k; w[cnt] = b * k; s -= k; k *= 2; } if(s \u003e 0) { cnt++; v[cnt] = a * s; w[cnt] = b * s; } n = cnt; for(int i = 1; i \u003c= n; i++) { for(int j = m; j \u003e= w[i]; j--) { f[j] = max(f[j], f[j - v[i]] + w[i]); } } 分组背包问题 for(int i = 0; i \u003c n; i++) { for(int j = m; j \u003e= 0; j--) { for(int k = 0; k \u003c s[i]; k++) if(v[i]][k] \u003c= j) f[j] = max(f[j], f[j - v[i][k]] + w[i][k]); } } ","date":"2021-07-10","objectID":"/algorithm_template/:11:1","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"线性DP 数组三角形 最长上升子序列 for(int i = 0; i \u003c n; i++) { f[i] = 1; for(int j = 0; j \u003c i; j++) { if(f[i] \u003e f[j]) f[i] = max(f[i], f[j] + 1) } } //求路线 for(int i = 0; i \u003c n; i++) { f[i] = 1; g[i] = 0; for(int j = 0; j \u003c i; j++) { if(f[i] \u003e f[j]) if(f[i] \u003c f[j] + 1) { f[i] = f[j] + 1; g[i] = j; } } } for(int i = 0, len = f[k]; i \u003c len; i++) { printf(\"%d\", g[k]); k = g[k]; } 最长上升子序列II for(int i = 0; i \u003c n; i++) { int l = 0, r = len; while(l \u003c r) { int mid = (l + r + 1) / 2; if(q[mid] \u003c a[i]) l = mid; else r = mid - 1; } len = max(len, r + 1); q[r + 1] = a[i]; } 最长公共子序列 for(int i = 1; i \u003c= n; i++) { for(int j = 1; j \u003c= m; j++) { f[i][j] = max(f[i - 1][j], f[i][j - 1]); if(a[i] == b[j]) f[i][j] = max(f[i][j], f[i - 1][j - 1] + 1); } } 编辑距离 for(int i = 0; i \u003c= m; i++) f[0][i] = i; for(int i = 0; i \u003c= n; i++) f[i][0] = i; for(int i = 1; i \u003c= n; i++) { for(int j = 1; j \u003c= m; j++) { f[i][j] = min(f[i - 1][j], f[i][j - 1]); if(a[i] == b[j]) f[i][j] = min(f[i][j], f[i - 1][j - 1]); else f[i][j] = min(f[i][j], f[i - 1][j - 1] + 1); } } ","date":"2021-07-10","objectID":"/algorithm_template/:11:2","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"区间DP 石子合并 for(int len = 2; len \u003c= n; len++) { for(int i = 1; i + len - 1\u003c= n; i++) { int l = i, r = i + len - 1; f[i][j] = 1e8; for(int k = i, k \u003c r; k++) { f[l][r] = min(f[l][r], f[l][k] + f[k + 1][r] + s[r] - s[l - 1]); } } } ","date":"2021-07-10","objectID":"/algorithm_template/:11:3","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"计数DP 整数划分 //背包做法 f[i][j] = f[i - 1][j] + f[i - 1][j - i] + f[i - 1][j - 2i] +... f[i - 1][j - si]; f[i][j - 1] = f[i - 1][j - 1] + f[i - 1][j - 2i] +... f[i - 1][j - si]; f[i][j] = f[i - 1][j] + f[i][j - 1]; for(int i = 1; i \u003c=n ;i++) for(int j = i; j \u003c= n; j++) { f[j] = (f[j] + f[j - 1]) % mod; } //计数dp //集合：所有总和为i,并且恰好表示成j个数的和的方案 for(int i = 1; i \u003c= n; i++) { for(int j = 1; j \u003c= i; j++) { f[i][j] = (f[i - 1][j] + f[i - j][j]) % mod } } return f[n][1] + .....f[n][n]; ","date":"2021-07-10","objectID":"/algorithm_template/:11:4","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"数位DP 数字统计 ","date":"2021-07-10","objectID":"/algorithm_template/:11:5","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"搜索和图论 ","date":"2021-07-10","objectID":"/algorithm_template/:12:0","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"DFS ","date":"2021-07-10","objectID":"/algorithm_template/:12:1","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"BFS ","date":"2021-07-10","objectID":"/algorithm_template/:12:2","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"邻接表 int h[N], e[N], ne[N], idx; init() { memset(h, -1, sizeof h); idx = 0; } void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx, idx++; } ","date":"2021-07-10","objectID":"/algorithm_template/:12:3","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"拓扑排序 bool toposort() { int hh = 0, tt = -1; for(int i = 1; i \u003c= n; i++) { if(!d[i]) q[++tt] = i; } while(hh \u003c= tt) { int t = qq[hh++]; for(int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; d[j]--; if(d[j] == 0) q[++tt] = j; } } return tt == n - 1; } ","date":"2021-07-10","objectID":"/algorithm_template/:12:4","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"单源最短路 //所有边权均为正数 //朴素Dijkstra O(n^2) //适合稠密图 int g[N][N]; int dist[N]; bool st[N]; int dijkstra() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; for(int i = 0; i \u003c n; i++) { int t = -1; for(int j = 1; j \u003c= n; j++) { if(!st[j] \u0026\u0026 (t == -1 || dist[t] \u003e dist[j])) t = j; } st[t] = 1; for(int j = 1; j \u003c= n; j++) { dist[j] = min(dist[j], dist[t] + g[t][j]); } } if(dist[n] == 0x3f) return -1; return dist[n]; } //堆优化版的Dijkstra //适合稀疏图 //O(mlogn) typedef pair\u003cint, int\u003e PII; int h[N], w[N], e[N], ne[N], idx; int dist[N]; bool st[N]; int dijkstra() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; st[1] = true; priority_queue\u003cPII, vector\u003cPII\u003e, greater\u003cPII\u003e\u003e heap; heap.push({0, 1}); while(heap.size()) { auto t = heap.top(); heap.pop(); int ver = t.second, dis = t.first; if(st[ver]) continue; st[ver] = true; for(int i = h[ver]; i != -1; i = ne[i]) { int j = e[i]; if(dist[j] \u003e dis + w[i]) { dist[j] = dis + w[i]; heap.push({dist[j], j}); } } } if(dist[n] == 0x3f3f3f3f) return -1; return dist[n]; } //存在负权边情况 //Bellman- Ford算法 //O(nm) int dist[N], backup[N]; struct Edge { int a, b, w; }edges[M]; int bellman_ford() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; for(int i = 0; i \u003c k; i++) { //避免后效性 memcpy(backup, dist, sizeof dist); for(int j = 0; j \u003c m; j++) { int a = edges[j].a; int b = edges[j].b; int w = edges[j].w; dist[b] = min(dist[b], backup[a] + w); } } // 两个正无穷的点之间的边是负的情况 if(dist[n] \u003e 0x3f3f3f3f / 2) return -1; return dist[n]; } //SPFA算法 是对Bellman-ford进行优化 一般O(m) 最坏O(nm) //利用广度优先算法进行优化 int spfa() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; st[1] = true; queue\u003cint\u003e q; q.push(1); while(q.size()) { int t = q.front(); q.pop(); st[t] = false; for(int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if(dist[j] \u003e dist[t] + w[i]) { dist[j] = dist[t] + w[i]; if(!st[j]) { q.push(j); st[j] = true; } } } } if(dist[n] == 0x3f3f3f3f) return -1; return dist[n]; } //拓展 spfa判断负环 //维护一个cnt数组 cnt[i] \u003e= n则有负环 bool spfa() { memset(dist, 0x3f, sizeof dist); queue\u003cint\u003e q; for(int i = 1; i \u003c= n; i++) { st[i] = true; q.push(i); } while(q.size()) { int t = q.front(); q.pop(); st[t] = false; for(int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if(dist[j] \u003e dist[t] + w[i]) { dist[j] = dist[t] + w[i]; cnt[j] = cnt[t] + 1; if(cnt[j] \u003e= n) return true; if(!st[j]) { q.push(j); st[j] = true; } } } } return false; } ","date":"2021-07-10","objectID":"/algorithm_template/:12:5","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"多源汇最短路 //Floyd //O(n^3) void floyd() { for(int k = 1; k \u003c= n; k++) { for(int i = 1; i \u003c= n; i++) { for(int j = 1; j \u003c= n; j++) { d[i][j] = min(d[i][j], d[i][k] + d[k][j]); } } } } ","date":"2021-07-10","objectID":"/algorithm_template/:12:6","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"最小生成树 //Prim //适合稠密图 //O(n^2) int prim() { memset(dist, 0x3f, sizeof dist); int res = 0; for(int i = 0; i \u003c n; i++) { int t = -1; for(int j = 1; j \u003c= n; j++) { if(!st[j] \u0026\u0026 (t == -1 || dist[t] \u003c dist[j])) t = j; if(i \u0026\u0026 dist[t] == INF) return INF; if(i) res += dist[t]; for(int j = 1; j \u003c= n; j++) dist[j] = min(dist[j], g[t][j]); st[t] = true; } } return res; } //Kruskal //适合稀疏图 //O(mlogm) struct Edges { int a, b, w; operator \u003c(const Edges\u0026 W) const { return w \u003c W.w; } }edegs[m]; sort(edegs, edges + m); for(int i = 1; i \u003c= n; i++) p[i] = i; int res = 0, cnt = 0; for(int i = 0; i \u003c m; i++) { int a = edges[i].a; int b = edges[i].b; int w = edges[i].w; a = find(a), b = find(b); if(a != b) { res += w; cnt++; p[a] = b; } } if(cnt \u003c n - 1) return -1; else return res; ","date":"2021-07-10","objectID":"/algorithm_template/:12:7","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"二分图 //染色法 //O(n + m) //二分图 当且仅当图中不含奇数环 bool flag = false; bool dfs(int u, int c) { for(int i = h[u]; i != -1; i = ne[i]) { int j = e[i]; if(!color[j]) { return dfs(j, 3 - c); } else if(color[j] == c) return false; } return true; } for(int i = 0; i \u003c= n; i++) { if(!color[i]) { if(!dfs(i, 1)) { flag = false; break; } } } //匈牙利算法 //O(mn) bool find(int x) { for(int i = h[x]; i != -1; i = ne[i]) { int j = e[i]; if(!st[j]) { st[j] = true; if(match[j] == 0 || find(match[j])) { match[j] = x; return true; } } } return false; } for(int i = 1; i \u003c= n1; i++) { memset(st, false, sizeof st); if(find(i)) res++; printf(\"%d\\n\", res); } ","date":"2021-07-10","objectID":"/algorithm_template/:12:8","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"线段树 //线段树是一种二叉搜索树，将一段区间划分为若干单位区间，每一个节点都存储着一个区间 //支持单点修改，区间求和，区间求最值，区间修改 struct Node { int l, r; int v; } tree[N * 4]; //建树 void build(int u, int l, int r) { tree[u] = {l, r}; if(l == r) return; int mid = l + r \u003e\u003e 1; build(u \u003c\u003c 1, l, mid); build(u \u003c\u003c 1 | 1, mid + 1, r); } //更新 void push_up(int u) { tree[u].v = max(tree[u \u003c\u003c 1].v, tree[u \u003c\u003c 1 | 1]. v); } //查询 int query(int u, int l, int r) { if(tree[u].l \u003e= l \u0026\u0026 tree[u].r \u003c= r) return tree[u].v; int mid = tree[u].l + tree[u].r \u003e\u003e 1; int v = 0; if(l \u003c= mid) v = query(u \u003c\u003c 1, l, r); if(r \u003e mid) v = max(v, query(u \u003c\u003c 1 | 1, l, r)); return v; } //修改 void modify(int u, int x, int v) { if(tree[u].l == x \u0026\u0026 tree[u].r == x) tree[u].v = v; else { int mid = tree[u].l + tree[u].r \u003e\u003e 1; if(x \u003c= mid) modify(u \u003c\u003c 1, x, v); else modify(u \u003c\u003c 1 | 1, x, v); tree[u].v = max(tree[u \u003c\u003c 1].v , tree[u \u003c\u003c 1 | 1].v); } } ","date":"2021-07-10","objectID":"/algorithm_template/:13:0","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":null,"content":" 想不出来 :D ","date":"0001-01-01","objectID":"/about/:0:0","tags":null,"title":"关于","uri":"/about/"}]