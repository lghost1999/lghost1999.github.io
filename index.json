[{"categories":["6.S081"],"content":"MIT 6.S801实验10","date":"2022-12-20","objectID":"/mit-6.s081-lab10-mmap/","tags":["操作系统"],"title":"MIT 6.S081 Lab10 Mmap","uri":"/mit-6.s081-lab10-mmap/"},{"categories":["6.S081"],"content":"课程知识 ","date":"2022-12-20","objectID":"/mit-6.s081-lab10-mmap/:1:0","tags":["操作系统"],"title":"MIT 6.S081 Lab10 Mmap","uri":"/mit-6.s081-lab10-mmap/"},{"categories":["6.S081"],"content":"xv6中的mmap memory mapped files将完整或者部分文件加载进内存，mmap将特定文件描述符的特定位置的数据映射到进程虚拟地址，就可以通过内存地址来读写文件。通过以lazy allocation的方式，并不会将文件从磁盘拷贝到内存，mmap借助VMA结构记录文件描述符，偏移量等元数据信息，用来保存虚拟地址对应的文件内容，当进程触发page fault的虚拟地址位于VMA内，操作系统才从磁盘中加载数据到内存，并映射到虚拟地址。 mmap和unmap系统调用： /** * addr: 想要映射到的地址，null由内核选择一个地址完成映射 * length: 想要映射的地址段长度 * prot: 保护位，设置读、写、执行权限 * flags：MAP_PRIVATE, 更新文件不会写入磁盘 MAP_SHARED, 更新文件需要写入磁盘 * fd: 传入的文件描述符 * offset: 偏移量 **/ void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset); /** * addr: 想要映射到的地址，null由内核选择一个地址完成映射 * length: 想要映射的地址段长度 **/ int munmap(void *addr, size_t length); ","date":"2022-12-20","objectID":"/mit-6.s081-lab10-mmap/:1:1","tags":["操作系统"],"title":"MIT 6.S081 Lab10 Mmap","uri":"/mit-6.s081-lab10-mmap/"},{"categories":["6.S081"],"content":"Linux中的mmap linux内核使用vm_area_struct结构来表示一个独立的虚拟内存区域，一个进程使用多个vm_area_struct结构来分别表示不同类型的虚拟内存区域.各个vm_area_struct结构使用链表或者树形结构链接，方便进程快速访问。mmap函数就是要创建一个新的vm_area_struct结构，并将其与文件的物理磁盘地址相连。vm_area_struct结构中包含区域起始和终止地址以及其他相关信息，同时也包含一个vm_ops指针，其内部可引出所有针对这个区域可以使用的系统调用函数。这样，进程对某一虚拟内存区域的任何操作需要用要的信息，都可以从vm_area_struct中获得： mmap调用过程： 进程在用户空间调用mmap函数，内核寻找一段空闲的满足要求的连续的虚拟地址，为该虚拟区分配一个vm_area_struct，该结构保存用户参数。将新建的vm_area_struct插入到链表中。 通过待映射的fd，获取对应的文件指针，调用内核空间的系统调用函数mmap(struct file *filp, struct vm_area_struct *vma)，创建页表项，实现文件物理地址和进程虚拟地址的映射，但并没有分配物理页面和进行数据拷贝。 进程访问映射空间，触发page fault，需要将文件数据拷贝到内存。调页过程先在交换缓存空间（swap cache）中寻找需要访问的内存页，如果没有则调用nopage函数把所缺的页从磁盘装入到主存中。若对文件进行了写操作，一定时间后系统会自动回写脏页面到对应磁盘地址。 ","date":"2022-12-20","objectID":"/mit-6.s081-lab10-mmap/:1:2","tags":["操作系统"],"title":"MIT 6.S081 Lab10 Mmap","uri":"/mit-6.s081-lab10-mmap/"},{"categories":["6.S081"],"content":"mmap和文件操作区别 read/write操作过程： 内核通过查找进程文件符表，定位到内核已打开文件集上的文件信息，从而找到此文件的inode。 通过inode查找要请求的文件页是否已经缓存在页缓存中。如果存在，则直接返回这片文件页的内容。 如果不存在，则通过inode定位到文件磁盘地址，将数据从磁盘复制到页缓存。之后再次发起读页面过程，进而将页缓存中的数据发给用户进程。 常规文件操作为了提高读写效率和保护磁盘，使用了页缓存机制。这样造成读文件时需要先将文件页从磁盘拷贝到页缓存中，由于页缓存处在内核空间，不能被用户进程直接寻址，所以还需要将页缓存中数据页再次拷贝到内存对应的用户空间中。常规文件操作需要从磁盘到页缓存再到用户主存的两次数据拷贝。而mmap只在发生缺页中断时，将磁盘数据拷贝到页缓存中，只进行一次拷贝。 mmap优点： 减少了数据拷贝次数，用内存读写代替I/O读写，提高了读写效率 实现了用户空间和内核空间的高效交互方式。两空间的各自修改操作可以直接反映在映射的区域内 提供进程间共享内存及相互通信的方式。不管是父子进程还是无亲缘关系的进程，都可以将自身用户空间映射到同一个文件或匿名映射到同一片区域。(动态链接库也是利用mmap) mmap通过懒加载的方式，节省内存，可用于实现高效的大规模数据传输。 mmap缺点： 需要维护内存和磁盘文件的映射关系，占用一定内存资源 需要处理缺页中断 ","date":"2022-12-20","objectID":"/mit-6.s081-lab10-mmap/:1:3","tags":["操作系统"],"title":"MIT 6.S081 Lab10 Mmap","uri":"/mit-6.s081-lab10-mmap/"},{"categories":["6.S081"],"content":"实验内容 ​ 本实验实现一个内存映射文件的功能mmap，将文件映射到内存中，在进行文件操作直接通过对内存进行读写，使用mmap可以避免对文件大量read和write操作带来的内核缓冲区和用户缓冲区之间的频繁的数据拷贝。采用延迟分配的策略，在真正访问是才进行内存页的分配，为此需要在进程结构体中维护mmap相关信息的VMA。 首先添加系统mmap和munmap系统调用，参考syscall实验 // user/user.h void *mmap(void*, int, int, int, int, int); int munmap(void*, int); // user/usys.pl entry(\"mmap\"); entry(\"munmap\"); // user/syscall.h ... #define SYS_mmap 22 #define SYS_munmap 23 // user/syscall.c ... extern uint64 sys_mmap(void); extern uint64 sys_munmap(void); static uint64 (*syscalls[])(void) = { ... [SYS_mmap] sys_mmap, [SYS_munmap] sys_munmap, } // user/sysfile.c uint64 sys_mmap(void) { return 0; } uint64 sys_munmap(void) { return 0; } // Makefile UPROGS=\\ ... $U/_mmaptest\\ 定义VMA结构体，保存mmap系统调用的相关参数信息，加入到proc结构体中 // kernel/proc.h struct vma{ uint64 addr; int length; int prot; int flags; struct file* mapped_file; int offset; int valid; }; struct proc { ... struct vma vmas[16]; }; 实现sys_mmap函数，获取系统调用参数，保存到相应的VMA结构体中。 // kernel/ uint64 sys_mmap(void) { int length, prot, flags, fd, offset, i; struct file* mapped_file; struct proc* p; if(argint(1, \u0026length) \u003c 0 || argint(2, \u0026prot) \u003c 0 || argint(3, \u0026flags) \u003c 0 || argint(4, \u0026fd) \u003c 0 || argint(5, \u0026offset) \u003c 0) return -1; p = myproc(); mapped_file = p-\u003eofile[fd]; // 文件不可写时，拥有PROT_WRITE权限映射不能是MAP_SHARED, 即不能对同一映射区域写入 if((!mapped_file-\u003ewritable) \u0026\u0026 (prot \u0026 PROT_WRITE) \u0026\u0026 (flags \u0026 MAP_SHARED)) return -1; for(i = 0; i \u003c 16; i++) { if(!p-\u003evmas[i].valid) { p-\u003evmas[i].addr = p-\u003esz; p-\u003evmas[i].length = length; p-\u003evmas[i].prot = prot; p-\u003evmas[i].flags = flags; p-\u003evmas[i].mapped_file = mapped_file; p-\u003evmas[i].offset = offset; p-\u003evmas[i].valid = 1; break; } } if(i == 16) return -1; filedup(mapped_file); p-\u003esz += length; return p-\u003evmas[i].addr; } 在usertrap中完成page fault处理 // kernel/trap.c void usertrap(void) { ... if(r_scause() == 8){ ... } else if(r_scause() == 13 || r_scause() == 15){ uint64 va = r_stval(); if(va \u003e= p-\u003esz || va \u003c p-\u003etrapframe-\u003esp) { p-\u003ekilled = 1; } else { int i; // 找到发生page fault时虚拟地址所在的VMA for (i = 0; i \u003c 16; i++) { if (p-\u003evmas[i].valid) { if (p-\u003evmas[i].addr \u003c= va \u0026\u0026 (p-\u003evmas[i].addr + p-\u003evmas[i].length) \u003e va) break; } } if(i == 16) { p-\u003ekilled = 1; } else { uint64 mem = (uint64) kalloc(); if (mem == 0){ p-\u003ekilled = 1; } else { memset((void *)mem, 0, PGSIZE); va = PGROUNDDOWN(va); ilock(p-\u003evmas[i].mapped_file-\u003eip); readi(p-\u003evmas[i].mapped_file-\u003eip, 0, mem, va - p-\u003evmas[i].addr, PGSIZE); iunlock(p-\u003evmas[i].mapped_file-\u003eip); int flags = PTE_U; if(p-\u003evmas[i].prot \u0026 PROT_READ) flags |= PTE_R; if(p-\u003evmas[i].prot \u0026 PROT_WRITE) flags |= PTE_W; if(p-\u003evmas[i].prot \u0026 PROT_EXEC) flags |= PTE_X; if(mappages(p-\u003epagetable, va, PGSIZE, mem, flags) != 0) { kfree((void *)mem); p-\u003ekilled = 1; } } } } } ... } 修改uvmunmap和uvmcopy，实现lazy allocaton // kernel/vm.c int uvmcopy(pagetable_t old, pagetable_t new, uint64 sz) { ... for(i = 0; i \u003c sz; i += PGSIZE){ if((pte = walk(old, i, 0)) == 0) panic(\"uvmcopy: pte should exist\"); if((*pte \u0026 PTE_V) == 0) continue; ... } } ... } // kernel/vm.c void uvmunmap(pagetable_t pagetable, uint64 va, uint64 npages, int do_free) { ... for(a = va; a \u003c va + npages*PGSIZE; a += PGSIZE){ if((pte = walk(pagetable, a, 0)) == 0) panic(\"uvmunmap: walk\"); if((*pte \u0026 PTE_V) == 0) continue; ... } } 实现sys_munmap函数，获取系统调用参数，解除映射关系 uint64 sys_munmap(void) { uint64 addr; int length, i; struct proc *p; if(argaddr(0, \u0026addr) \u003c 0 || argint(1, \u0026length) \u003c 0) return -1; p = myproc(); for(i = 0; i \u003c 16; ++i) { if (p-\u003evmas[i].valid == 1) { if (p-\u003evmas[i].addr \u003c= addr \u0026\u0026 (p-\u003evmas[i].addr + p-\u003evmas[i].length) \u003e addr) break; } } if (i == 16) { return -1; } // 若flags参数为MAP_SHARED，需要将页面写回磁盘 if(p-\u003evmas[i].flags == MAP_SHARED \u0026\u0026 (p-\u003evmas[i].prot \u0026 PROT_WRITE) != 0) { filewrite(p-\u003evmas[i].mapped_file, addr, length); } //根据addr和length解除映射，并修改对应VMA的addr和length if (p-\u003evmas[i].addr == addr \u0026\u0026 p-\u003evmas[i].length == length) { uvmunmap(p-\u003epagetable, addr, length/PGSIZE, 1); fileclose(p-\u003evmas[i].mapped_file); p-\u003evmas[i].valid = 0; } else if (p-\u003evmas[i].addr == addr) { uvmunmap(p-\u003epagetable, addr,","date":"2022-12-20","objectID":"/mit-6.s081-lab10-mmap/:2:0","tags":["操作系统"],"title":"MIT 6.S081 Lab10 Mmap","uri":"/mit-6.s081-lab10-mmap/"},{"categories":["6.S081"],"content":"MIT 6.S801实验9","date":"2022-12-13","objectID":"/mit-6.s081-lab9-fs/","tags":["操作系统"],"title":"MIT 6.S081 Lab9 FS","uri":"/mit-6.s081-lab9-fs/"},{"categories":["6.S081"],"content":"课程知识 ","date":"2022-12-13","objectID":"/mit-6.s081-lab9-fs/:1:0","tags":["操作系统"],"title":"MIT 6.S081 Lab9 FS","uri":"/mit-6.s081-lab9-fs/"},{"categories":["6.S081"],"content":"文件系统 文件系统的目的是组织和存储数据。文件系统通常支持用户和应用程序之间的数据共享，以及持久性，以便在重新启动后数据仍然可用。xv6中的文件系统较小，整体可以分为7层 层级 描述 文件描述符（File descriptor） 使用统一接口对资源进行操作，抽象了Unix资源 路径名（Pathname） 提供分层路径名，通过递归来解析 目录（Directory） 层次化的命名空间，由多个页表项组成 索引结点（Inode） 代表文件对象，实现了read/write等基本文件调用 日志（Logging） 日志可以用于崩溃后恢复 缓冲区高速缓存（Buffer cache） 缓存磁盘块到内存，避免频繁读写并同步磁盘块的访问 磁盘（Disk） 提供持久化存储 文件系统常见的系统调用： //为file1创建另一个名为file2的文件，硬连接，引用计数+1 int link(char* file1, char* file2); //删除file2文件，真实的inode的节点可能不会删除，引用计数-1 int unlink(char* file); //向文件读出n个字符 int read(int fd, char* buf, int n); //向文件写入n个字符 //write和read都没有针对文件的offset参数，文件系统维护了文件的offset。 int write(int fd, char* buf, int n); ","date":"2022-12-13","objectID":"/mit-6.s081-lab9-fs/:1:1","tags":["操作系统"],"title":"MIT 6.S081 Lab9 FS","uri":"/mit-6.s081-lab9-fs/"},{"categories":["6.S081"],"content":"磁盘 最常见的存储设备包括SSD和HDD，SSD完成一个磁盘块的读取是0.1~1 ms，HDD通常在10ms 扇区（sector）是磁盘驱动可以读写的最小单元，通常为512B。磁盘块（block）是文件存取的最小单位，由文件系统定义通常一个block对应多个sector。 xv6上磁盘块的布局结构： block 0：引导扇区，包含了启动操作系统的代码 block 1：超级块，包含文件系统的元数据(文件系统大小，数据块数，索引节点数和日志中的块数) block 2 ~ block 31: 日志块 block 32 ~ block 44: 索引节点块，一个inode节点64B block 45 : bitmap block 追踪正在使用的数据块 block 46 ~ : 数据块 ","date":"2022-12-13","objectID":"/mit-6.s081-lab9-fs/:1:2","tags":["操作系统"],"title":"MIT 6.S081 Lab9 FS","uri":"/mit-6.s081-lab9-fs/"},{"categories":["6.S081"],"content":"日志层 文件系统需要考虑崩溃恢复。许多文件系统操作都涉及对磁盘的多次写入，可能会出现崩溃导致文件系统处于不一致状态。例如执行上述echo \"hi\" \u003e x的操作，可能会出现标记为文件的inode节点的其他属性未更新，或者留下了已分配的block 595却未被引用等多种情况。 xv6不会直接写入磁盘上的文件系统，会在磁盘log记录所有磁盘写入的描述，然后向磁盘写入一条特殊commit，系统调用将写入磁盘上的文件系统，写完后清除日志。 如果崩溃发生在操作提交之前，磁盘上的登录将不会被标记为已完成，将不会进行恢复 如果崩溃发生在操作提交之后，恢复将重放所有写入操作，可能会重复这些操作。 日志驻留在超级块中指定的已知固定位置。它由一个头块和一系列更新块的副本组成。头块包含一个扇区号数组以及日志块的计数。磁盘上的头块中的计数或者为零，表示日志中没有事务；或者为非零，表示日志包含一个完整的已提交事务，并具有指定数量的日志块。在事务提交时Xv6才向头块写入数据，在此之前不会写入，并在将日志块复制到文件系统后将计数设置为零。事务中途崩溃将导致日志头块中的计数为零；提交后的崩溃将导致非零计数。 日志系统将多个系统调用写入累积到一个事务中，单个提交可能涉及多个完整系统调用。同时提交多个事务称为组提交，组提交减少了磁盘操作的数量。 ","date":"2022-12-13","objectID":"/mit-6.s081-lab9-fs/:1:3","tags":["操作系统"],"title":"MIT 6.S081 Lab9 FS","uri":"/mit-6.s081-lab9-fs/"},{"categories":["6.S081"],"content":"inode 文件系统中核心的数据结构就是inode和file descriptor。inode表示文件对象，并不依赖于文件名，通过自身编号进行区分，文件系统内部通过数字引用inode。inode必须有一个link count来跟踪指向这个inode的文件名的数量，只能在link count为0的时候被删除。实际中还有一个openfd count，也就是当前打开了文件的文件描述符计数，一个文件只能在这两个计数器都为0的时候才能被删除。后者主要与用户进程进行交互。 // kernel/fs.h struct dinode { short type; // 表明文件还是目录 short major; // Major device number (T_DEVICE only) short minor; // Minor device number (T_DEVICE only) short nlink; // 指向该inode的文件名数 uint size; // 文件数据大小 uint addrs[NDIRECT+1];// 文件数据块地址，0~11为数据块地址，最后一个为间接地址块的地址 // 一个block可以装载256个block编号，每一个block编号为4B }; 间接索引块记录： inode包含12个直接块，最后一个元素为间接块的地址，可以从inode中列出的块加载文件的前12个字节，间接块中加载256个字节，xv6中最大文件为268 KB。 ","date":"2022-12-13","objectID":"/mit-6.s081-lab9-fs/:1:4","tags":["操作系统"],"title":"MIT 6.S081 Lab9 FS","uri":"/mit-6.s081-lab9-fs/"},{"categories":["6.S081"],"content":"目录 在xv6中，每个目录包含多个目录项（directory entry），每个entry由固定的格式： // kernel/fs.h struct dirent { // 文件或者子目录的inode编号 ushort inum; // 文件或者子目录名 char name[DIRSIZ]; }; 在xv6中查找路径名/y/x： 从root inode开始查找，读取root inode内容，在block 32的64~128字节的位置 读取root inode包含的所有block，block内容由目录项组成。找到目录y，对应的inode编号为a 从inode a对应的所有block查找，找到文件x，返回对应的inode编号b，即为最终结果 输入echo \"hi\" \u003e x底层实现： 写入block 33节点，首先将inode节点标记从空闲改为文件状态，并写回磁盘，再写入inode的其他属性。 写入根目录对应的block 46，因为此时正在向根目录创建一个新文件 写入block 32节点，更新根目录对应的inode，修改对应的size字段 写入block 45节点，选择未被使用的节点595进行写入，需要将该bit设置为1 写入block 595节点，写入具体内容，每个字符写入一次 写入block 33节点，更新inode的size字段，并修改addrs地址，将block 595编号写入 ","date":"2022-12-13","objectID":"/mit-6.s081-lab9-fs/:1:5","tags":["操作系统"],"title":"MIT 6.S081 Lab9 FS","uri":"/mit-6.s081-lab9-fs/"},{"categories":["6.S081"],"content":"实验内容 ","date":"2022-12-13","objectID":"/mit-6.s081-lab9-fs/:2:0","tags":["操作系统"],"title":"MIT 6.S081 Lab9 FS","uri":"/mit-6.s081-lab9-fs/"},{"categories":["6.S081"],"content":"Large files(moderate) xv6上一个inode节点包含12个直接块和一个间接块，xv6文件最多为12 + 256 = 268个块，即268KB, 需要将一个直接块改为二级间接块，这样最多可以容纳12 + 256 + 256 * 256个块，满足大文件需求。 修改一个直接块为二级间接块 // kernel/fs.h #define NDIRECT 11 #define NINDIRECT (BSIZE / sizeof(uint)) #define NIINDIRECT ((BSIZE / sizeof(uint)) * (BSIZE / sizeof(uint))) #define MAXFILE (NDIRECT + NINDIRECT + NIINDIRECT) struct dinode { ... uint addrs[NDIRECT+2]; // Data block addresses }; // kernel/file.h struct inode { ... uint addrs[NDIRECT+2]; }; 修改bmap分配二级间接块 // kernel/fs.c static uint bmap(struct inode *ip, uint bn) { ... if(bn \u003c NIINDIRECT){ if((addr = ip-\u003eaddrs[NDIRECT + 1]) == 0) ip-\u003eaddrs[NDIRECT + 1] = addr = balloc(ip-\u003edev); bp = bread(ip-\u003edev, addr); a = (uint*)bp-\u003edata; if((addr = a[bn / NINDIRECT]) == 0){ a[bn / NINDIRECT] = addr = balloc(ip-\u003edev); log_write(bp); } brelse(bp); bp = bread(ip-\u003edev, addr); a = (uint*)bp-\u003edata; if((addr = a[bn % NINDIRECT]) == 0) { a[bn % NINDIRECT] = addr = balloc(ip-\u003edev); log_write(bp); } brelse(bp); return addr; } panic(\"bmap: out of range\"); } 修改itrunc回收二级间接块 // kernel/fs.c void itrunc(struct inode *ip) { ... if(ip-\u003eaddrs[NDIRECT + 1]){ bp = bread(ip-\u003edev, ip-\u003eaddrs[NDIRECT + 1]); a = (uint*)bp-\u003edata; for(i = 0; i \u003c NINDIRECT; i++){ struct buf *t; uint *b; t = bread(ip-\u003edev, a[i]); b = (uint*)t-\u003edata; for(j = 0; j \u003c NINDIRECT; j++){ if(b[j]) bfree(ip-\u003edev, b[j]); } brelse(t); bfree(ip-\u003edev, a[i]); } brelse(bp); bfree(ip-\u003edev, ip-\u003eaddrs[NDIRECT + 1]); ip-\u003eaddrs[NDIRECT + 1] = 0; } ip-\u003esize = 0; iupdate(ip); } ","date":"2022-12-13","objectID":"/mit-6.s081-lab9-fs/:2:1","tags":["操作系统"],"title":"MIT 6.S081 Lab9 FS","uri":"/mit-6.s081-lab9-fs/"},{"categories":["6.S081"],"content":"Symbolic links(moderate) 本实验将实现一个系统调用symlink(char *target, char *path)，该调用在引用由target命名的文件的路径处创建一个新的符号链接。 添加系统调用，参考syscall实验 // user/user.h int symlink(char*, char*); // user/usys.pl entry(\"symlink\"); // user/syscall.h ... #define SYS_symlink 22 // user/syscall.c ... extern uint64 sys_symlink(void); static uint64 (*syscalls[])(void) = { ... [SYS_symlink] sys_symlink, } // user/sysfile.c uint64 sys_symlink(void) { return 0; } // Makefile UPROGS=\\ ... $U/_symlinktest\\ 添加宏定义 // kernel/fcntl.h #define O_NOFOLLOW 0x800 // kernel/stat.h #define T_SYMLINK 4 实现sys_symlink函数 // kernel/sysfile.c uint64 sys_symlink(void) { char target[MAXPATH], path[MAXPATH]; if(argstr(0, target, MAXPATH) \u003c 0 || argstr(1, path, MAXPATH) \u003c 0) return -1; begin_op(); struct inode *node = create(path, T_SYMLINK, 0, 0); if(node == 0) { end_op(); return -1; } if(writei(node, 0, (uint64)target, 0, MAXPATH) \u003c MAXPATH) { iunlockput(node); end_op(); return -1; } iunlockput(node); end_op(); return 0; } 修改sys_open函数，支持符号链接，如果链接文件也是符号链接，则必须递归地跟随它，直到到达非链接文件为止。 // kernel/sysfile.c uint64 sys_open(void){ ... if(ip-\u003etype == T_SYMLINK \u0026\u0026 !(omode \u0026 O_NOFOLLOW)) { for(int i = 0; i \u003c 10; ++i) { if(readi(ip, 0, (uint64)path, 0, MAXPATH) != MAXPATH) { iunlockput(ip); end_op(); return -1; } iunlockput(ip); ip = namei(path); if(ip == 0) { end_op(); return -1; } ilock(ip); if(ip-\u003etype != T_SYMLINK) break; } if(ip-\u003etype == T_SYMLINK) { iunlockput(ip); end_op(); return -1; } } if((f = filealloc()) == 0 || (fd = fdalloc(f)) \u003c 0){ ... } ","date":"2022-12-13","objectID":"/mit-6.s081-lab9-fs/:2:2","tags":["操作系统"],"title":"MIT 6.S081 Lab9 FS","uri":"/mit-6.s081-lab9-fs/"},{"categories":["6.S081"],"content":"MIT 6.S801实验8","date":"2022-12-06","objectID":"/mit-6.s081-lab8-lock/","tags":["操作系统"],"title":"MIT 6.S081 Lab8 Lock","uri":"/mit-6.s081-lab8-lock/"},{"categories":["6.S081"],"content":"课程知识 ","date":"2022-12-06","objectID":"/mit-6.s081-lab8-lock/:1:0","tags":["操作系统"],"title":"MIT 6.S081 Lab8 Lock","uri":"/mit-6.s081-lab8-lock/"},{"categories":["6.S081"],"content":"锁 ​ 现代计算机中多个CPU之间独立执行，同时多个CPU共享物理内存，并行访问内核中的数据结构时，需要使用锁来协调共享数据的更新以确保数据的一致性。举个例子，在xv6中，两个进程在两个不同的CPU上调用wait，wait通过kfree函数释放子进程的物理页面。在内核中，内核分配器通过链表的方式维护空闲页面，内核初始化时将所有的空闲页面以头插法的方式插入到空闲链表，分配物理页面时取出头节点，释放页面时将页面首地址插入到空闲链表头部。 // kernel/kalloc.c //空闲链表结构 struct run { struct run *next; }; struct { struct spinlock lock; struct run *freelist; } kmem; // 释放页面 void kfree(void *pa) { ... r = (struct run*)pa; acquire(\u0026kmem.lock); r-\u003enext = kmem.freelist; kmem.freelist = r; release(\u0026kmem.lock); } ​ 在释放页面时包含两个操作，首先将页面插入到链表头部，再将链表头更新为新插入的页面，两个进程同时调用wait操作，就会出现竞态条件，导致出现错误，因此需要通过锁机制来保证指令执行顺序，acquire和release之间的指令序列被称为临界区域。锁用来串行化并发的临界区域，保证同一时刻只有一个进程在临界区运行。 ​ xv6中的所有锁： ","date":"2022-12-06","objectID":"/mit-6.s081-lab8-lock/:1:1","tags":["操作系统"],"title":"MIT 6.S081 Lab8 Lock","uri":"/mit-6.s081-lab8-lock/"},{"categories":["6.S081"],"content":"死锁 ​ 死锁的四个条件：互斥，不剥夺，请求与保持，循环等待 ​ 如果在内核中执行的代码路径必须同时持有数个锁，那么所有代码路径以相同的顺序获取这些锁是很重要的。如果它们不这样做，就有死锁的风险。为了避免这种死锁，所有代码路径必须以相同的顺序获取锁，需要确定对于所有的锁对象的全局的顺序，先获取排序靠前的目录的锁，再获取排序靠后的目录的锁、 ​ 遵守全局死锁避免的顺序可能会出人意料地困难。有时锁顺序与逻辑程序结构相冲突，例如代码模块M1调用模块M2，但是锁顺序要求在M1中的锁之前获取M2中的锁。有时锁的身份是事先不知道的，也许是因为必须持有一个锁才能发现下一个要获取的锁的身份。 ","date":"2022-12-06","objectID":"/mit-6.s081-lab8-lock/:1:2","tags":["操作系统"],"title":"MIT 6.S081 Lab8 Lock","uri":"/mit-6.s081-lab8-lock/"},{"categories":["6.S081"],"content":"自旋锁 ​ 自旋锁通过忙等的方式，线程在获取锁的过程中保持执行，反复检查锁变量是否可用。一旦获取了自旋锁，线程会一直保持该锁，直到显示释放自旋锁。自旋锁避免了线程切换的开销，适合占用时间短的场景。 xv6中自旋锁表示为spinlock结构体，当锁可用时locked字段为0，当被持有时不为0 // kernel/spinlock.h struct spinlock { uint locked; // Is the lock held? // For debugging: char *name; // Name of lock. struct cpu *cpu; // The cpu holding the lock. }; 自旋锁的实现逻辑： void acquire(struct spinlock* lk) // does not work! { for(;;) { //存在两个进程同时到达，同时占用该自旋锁，需要将下面这个两条作为原子指令执行 //需要通过amoswap指令，在RISC-V上是amoswap r,a amoswap 交换寄存器r和内存地址a的值 if(lk-\u003elocked == 0) { lk-\u003elocked = 1; break; } } } 自旋锁在xv6中的实现： // kernel/spinlock.c void acquire(struct spinlock *lk) { //获取锁操作需要先关闭中断 //spinlock需要处理两类并发，不同CPU之间和相同CPU上中断程序和普通程序之间的并发 //如果自旋锁被中断处理程序所使用，那么CPU必须保证在启用中断的情况下永远不能持有该锁。 push_off(); if(holding(lk)) panic(\"acquire\"); //在risc-v中, __sync_lock_test_and_set(\u0026lk-\u003elocked, 1)对应amoswap指令 //该函数返回交换之前lk-locked的值，若返回值为0，表示我们拿到了锁 while(__sync_lock_test_and_set(\u0026lk-\u003elocked, 1) != 0) ; //阻止CPU和编译器进行指令重排，编译器会优化指令顺序，在并发场景下对临界区和锁操作重排可能导致错误 //任何在synchronize之前的load和store操作，都不能移动它之后，保证临界区操作都在获得锁之后进行 __sync_synchronize(); lk-\u003ecpu = mycpu(); } // kernel/spinlock.c void release(struct spinlock *lk) { if(!holding(lk)) panic(\"release\"); lk-\u003ecpu = 0; __sync_synchronize(); //C标准编译器用多个存储指令实现赋值，先加载cache line，再更新cache line,可能会出现并发代码 //使用__sync_lock_release对应amoswap指令，将lk-\u003elocked清0 __sync_lock_release(\u0026lk-\u003elocked); pop_off(); } ","date":"2022-12-06","objectID":"/mit-6.s081-lab8-lock/:1:3","tags":["操作系统"],"title":"MIT 6.S081 Lab8 Lock","uri":"/mit-6.s081-lab8-lock/"},{"categories":["6.S081"],"content":"睡眠锁 ​ 自旋锁适合占用时间短的场景。在长时间保持锁的场景下，例如读写磁盘文件，对于磁盘的操作需要几十毫秒，如果使用自旋锁，则导致获取进程进程在自旋时浪费很长时间的CPU。同时自旋锁采用忙等，一个进程在持有自旋锁时不会让出CPU。 ​ 睡眠锁在等待时让出CPU，睡眠锁有一个被自旋锁保护的锁定字段，acquiresleep调用sleep让出CPU并释放自旋锁，其他线程可以在acquiresleep等待时执行。睡眠锁保持中断使能，不能用在中断处理程序中，也不能在自旋锁临界区使用，acquiresleep可能会让出CPU。 // kernel/sleeplock.h struct sleeplock { uint locked; // Is the lock held? struct spinlock lk; // spinlock protecting this sleep lock // For debugging: char *name; // Name of lock. int pid; // Process holding lock }; void acquiresleep(struct sleeplock *lk) { acquire(\u0026lk-\u003elk); while (lk-\u003elocked) { sleep(lk, \u0026lk-\u003elk); } lk-\u003elocked = 1; lk-\u003epid = myproc()-\u003epid; release(\u0026lk-\u003elk); } ","date":"2022-12-06","objectID":"/mit-6.s081-lab8-lock/:1:4","tags":["操作系统"],"title":"MIT 6.S081 Lab8 Lock","uri":"/mit-6.s081-lab8-lock/"},{"categories":["6.S081"],"content":"实验内容 ","date":"2022-12-06","objectID":"/mit-6.s081-lab8-lock/:2:0","tags":["操作系统"],"title":"MIT 6.S081 Lab8 Lock","uri":"/mit-6.s081-lab8-lock/"},{"categories":["6.S081"],"content":"Memory allocator(moderate) 本实验需要将原来共有的空间列表改为为每个CPU维护一个空闲列表，当CPU需要内存时，从对应的空闲列表中获取，若对应的空闲列表为空，则从其他不为空的空闲列表中回去一个内存页。 修改空闲列表，为每一个空闲列表初始化对应的锁 // kernel/kalloc.c struct { struct spinlock lock; struct run *freelist; } kmem[NCPU]; void kinit() { char lockname[8]; for(int i = 0; i \u003c NCPU; i++) { snprintf(lockname, 6, \"kmem%d\", i); initlock(\u0026kmem[i].lock, lockname); } freerange(end, (void*)PHYSTOP); } 修改kalloc函数，在对应空闲列表为空时，去其他空闲列表获取，注意在调用cpuid函数时，需要关闭中断。 void * kalloc(void) { struct run *r; if(r) { kmem[id].freelist = r-\u003enext; } else { for(int i = 0; i \u003c NCPU; i++) { if(i == id) continue; acquire(\u0026kmem[i].lock); r = kmem[i].freelist; if(r) { kmem[i].freelist = r-\u003enext; release(\u0026kmem[i].lock); break; } release(\u0026kmem[i].lock); } } release(\u0026kmem[id].lock); pop_off(); if(r) memset((char*)r, 5, PGSIZE); // fill with junk return (void*)r; } 修改kfree函数，将内存页添加到对应的空闲列表 void kfree(void *pa) { ... memset(pa, 1, PGSIZE); r = (struct run*)pa; push_off(); int id = cpuid(); acquire(\u0026kmem[id].lock); r-\u003enext = kmem[id].freelist; kmem[id].freelist = r; release(\u0026kmem[id].lock); pop_off(); } ","date":"2022-12-06","objectID":"/mit-6.s081-lab8-lock/:2:1","tags":["操作系统"],"title":"MIT 6.S081 Lab8 Lock","uri":"/mit-6.s081-lab8-lock/"},{"categories":["6.S081"],"content":"Buffer cache(hard) 本实验是将原来共有的磁盘块缓冲区转化为多个缓冲区，由原来的一个双向链表转化为多个双向链表，减少锁的争用，实现缓冲区分配和回收的并行执行。 修改单个缓冲区为固定个哈希桶 // kernel/params.h #define NBUCKET 13 // kernel/bio.c struct bucket{ struct spinlock lock; struct buf head; }; struct { struct bucket bucket[NBUCKET]; struct buf buf[NBUF]; } bcache; 修改binit函数，初始化NBUCKET个哈希桶 // kernel/bio.c void binit(void) { struct buf *b; char lockname[10]; for(int i = 0; i \u003c NBUCKET; i++) { snprintf(lockname, 10, \"bcache%d\", i); initlock(\u0026bcache.bucket[i].lock, lockname); bcache.bucket[i].head.prev = \u0026bcache.bucket[i].head; bcache.bucket[i].head.next = \u0026bcache.bucket[i].head; } for(b = bcache.buf; b \u003c bcache.buf+NBUF; b++){ b-\u003enext = bcache.bucket[0].head.next; b-\u003eprev = \u0026bcache.bucket[0].head; initsleeplock(\u0026b-\u003elock, \"buffer\"); bcache.bucket[0].head.next-\u003eprev = b; bcache.bucket[0].head.next = b; } } 添加时间戳属性，使用时间戳获取最近最久未使用的块 // kernel/buf.h struct buf { ... uint timestamp; }; 修改bget函数，对缓存不命中的数据块分配，从当前散列桶开始查找，找到每个桶中最近最久未使用的数据块进行分配，若当前桶中不存在未使用的缓冲区，则到下一个桶中查找。需要注意对数据块的缓存查找和缓存不命中的缓冲区分配是一个原子操作，需要注意锁的申请和释放。 // kernel/bio.c static struct buf* bget(uint dev, uint blockno) { struct buf *b; int id = blockno % NBUCKET; acquire(\u0026bcache.bucket[id].lock); // Is the block already cached? for(b = bcache.bucket[id].head.next; b != \u0026bcache.bucket[id].head; b = b-\u003enext){ if(b-\u003edev == dev \u0026\u0026 b-\u003eblockno == blockno){ b-\u003erefcnt++; acquire(\u0026tickslock); b-\u003etimestamp = ticks; release(\u0026tickslock); release(\u0026bcache.bucket[id].lock); acquiresleep(\u0026b-\u003elock); return b; } } // Not cached. // Recycle the least recently used (LRU) unused buffer. b = 0; for(int i = id, k = 0; k \u003c NBUCKET; i = (i + 1) % NBUCKET, k++) { if(i != id) { if(!holding(\u0026bcache.bucket[i].lock)) acquire(\u0026bcache.bucket[i].lock); else continue; } struct buf *t; for(t = bcache.bucket[i].head.next; t != \u0026bcache.bucket[i].head; t = t-\u003enext){ if(t-\u003erefcnt == 0 \u0026\u0026 (b == 0 || t-\u003etimestamp \u003c b-\u003etimestamp)) b = t; } if(b) { if(i != id) { b-\u003enext-\u003eprev = b-\u003eprev; b-\u003eprev-\u003enext = b-\u003enext; release(\u0026bcache.bucket[i].lock); b-\u003enext = bcache.bucket[id].head.next; b-\u003eprev = \u0026bcache.bucket[id].head; bcache.bucket[id].head.next-\u003eprev = b; bcache.bucket[id].head.next = b; } b-\u003edev = dev; b-\u003eblockno = blockno; b-\u003evalid = 0; b-\u003erefcnt = 1; acquire(\u0026tickslock); b-\u003etimestamp = ticks; release(\u0026tickslock); release(\u0026bcache.bucket[id].lock); acquiresleep(\u0026b-\u003elock); return b; } else { if(i != id) release(\u0026bcache.bucket[i].lock); } } panic(\"bget: no buffers\"); } 修改brelse函数，bpin函数和bunpin函数，适配固定个散列桶 // kernel/bio.c void brelse(struct buf *b) { if(!holdingsleep(\u0026b-\u003elock)) panic(\"brelse\"); releasesleep(\u0026b-\u003elock); int id = b-\u003eblockno % NBUCKET; acquire(\u0026bcache.bucket[id].lock); b-\u003erefcnt--; acquire(\u0026tickslock); b-\u003etimestamp = ticks; release(\u0026tickslock); release(\u0026bcache.bucket[id].lock); } // kernel/bio.c void bpin(struct buf *b) { int id = b-\u003eblockno % NBUCKET; acquire(\u0026bcache.bucket[id].lock); b-\u003erefcnt++; release(\u0026bcache.bucket[id].lock); } // kernel/bio.c void bunpin(struct buf *b) { int id = b-\u003eblockno % NBUCKET; acquire(\u0026bcache.bucket[id].lock); b-\u003erefcnt--; release(\u0026bcache.bucket[id].lock); } ","date":"2022-12-06","objectID":"/mit-6.s081-lab8-lock/:2:2","tags":["操作系统"],"title":"MIT 6.S081 Lab8 Lock","uri":"/mit-6.s081-lab8-lock/"},{"categories":["6.S081"],"content":"MIT 6.S801实验7","date":"2022-11-29","objectID":"/mit-6.s081-lab7-thread/","tags":["操作系统"],"title":"MIT 6.S081 Lab7 Thread","uri":"/mit-6.s081-lab7-thread/"},{"categories":["6.S081"],"content":"课程知识 ","date":"2022-11-29","objectID":"/mit-6.s081-lab7-thread/:1:0","tags":["操作系统"],"title":"MIT 6.S081 Lab7 Thread","uri":"/mit-6.s081-lab7-thread/"},{"categories":["6.S081"],"content":"线程 任何操作系统都可能运行比CPU数量更多的进程，所以需要一个进程间分时共享CPU的方案。常见的是通过将进程多路复用到硬件CPU上，使每个进程产生一种错觉，即它有自己的虚拟CPU。当进程等待设备I/O和系统调用完成时，xv6使用sleep和wakeup机制唤醒切换；或者xv6周期性地强制切换长时间计算的进程。这种多路复用产生了每个进程都有自己的CPU的错觉，就像xv6使用内存分配器和硬件页表来产生每个进程都有自己内存的错觉一样。 线程是单个串行执行代码的单元，只占用一个CPU并且顺序接收并执行指令。每个CPU可以运行一个线程，一般来说，线程数远远多于CPU核数，每个CPU核会在多个线程之间切换。线程之间共享内存，多个线程都运行在同一个地址空间，需要通过锁来保证对共享数据的更新操作。线程具有： 程序计数器：表示当前执行指令的位置 （所在CPU的PC得到） 一组寄存器：保存变量 （所在CPU的寄存器得到） 栈：记录函数调用的记录，并反映了当前线程的执行点 xv6中线程的状态： RUNNING 正在运行的线程 RUNABLE 就绪线程 SLEEPING 等待I/O事件的阻塞线程 xv6中一个用户进程包含一个线程，线程控制了用户代码指令的执行，同时支持内核线程的概念，对于每个用户进程都有一个内核线程执行来自用户进程的调用，所有的内核线程共享内核内存。每个进程的结构体中包含kstack字段，指向内核栈；同时内核可以调用myproc函数获取当前CPU正在运行的进程。两种方法都可以区分不同的内核线程。 ","date":"2022-11-29","objectID":"/mit-6.s081-lab7-thread/:1:1","tags":["操作系统"],"title":"MIT 6.S081 Lab7 Thread","uri":"/mit-6.s081-lab7-thread/"},{"categories":["6.S081"],"content":"线程调度 线程调度有内核发起，内核会在定时器中断和系统调用时让出CPU，xv6为每个CPU核创建了一个线程调度器。在每个CPU核上，发生进程切换时将CPU的控制权从用户进程给到内核，用户进程对应的内核线程会让出CPU。 当一个程序运行时，用户进程的一个用户线程在运行，如果线程执行了一个系统调用或者中断陷入内核，相应的状态会保存在程序的trapframe中，包括PC和寄存器，CPU会被切换到内核栈上，内核线程会执行系统调用或者中断处理程序，处理完成后返回到用户空间，trapframe中保存的用户进程状态会被恢复。 从一个用户进程切换到另一个用户进程，以shell进程切换到cat进程为例： 从shell内核线程切换到cat内核线程的过程： xv6首先将shell程序的内核寄存器保存在一个context对象 xv6恢复cat内核线程的context对象 xv6会继续在cat的内核线程栈上完成中断处理程序 （因为是cat程序发出的中断请求） 恢复cat程序的trapframe中的用户进程状态，返回到用户空间的cat线程中继续执行 在xv6中用户线程的寄存器保存在trapframe中，内核线程的寄存器保存在context中。每一个CPU都有一个调度器线程，调度器线程也有自己的context对象。每个内核线程的context对象保存在用户进程对应的proc结构体中，调度器线程没有对应的进程，context对象保存在CPU结构体中，运行在CPU的线程，决定让出CPU时，会切换到CPU对应的调度器线程，并由调度器线程切换到下一个进程。 // kernel/proc.h struct context { uint64 ra; uint64 sp; // callee-saved uint64 s0; uint64 s1; uint64 s2; uint64 s3; uint64 s4; uint64 s5; uint64 s6; uint64 s7; uint64 s8; uint64 s9; uint64 s10; uint64 s11; }; 定时器中断具体过程： 首先进行中断处理程序usertrap，usertrap调用yield放弃CPU // kernel/trap.c void usertrap(void) { ... //定时器中断 if(which_dev == 2) yield(); ... } yield获取当前进程的锁，并释放持有的锁，并修改进程状态为RUNNABLE，调用sched // kernel/proc.c void yield(void) { struct proc *p = myproc(); acquire(\u0026p-\u003elock); p-\u003estate = RUNNABLE; sched(); release(\u0026p-\u003elock); } sched是线程切换的核心，检查条件，将当前内核线程的寄存器保存，并恢复当前CPU核的调度器线程的寄存器继续执行。调度器线程的ra寄存器保存swtch函数返回地址，scheduler函数， // kernel/proc.c void sched(void) { int intena; struct proc *p = myproc(); if(!holding(\u0026p-\u003elock)) panic(\"sched p-\u003elock\"); if(mycpu()-\u003enoff != 1) panic(\"sched locks\"); if(p-\u003estate == RUNNING) panic(\"sched running\"); if(intr_get()) panic(\"sched interruptible\"); intena = mycpu()-\u003eintena; swtch(\u0026p-\u003econtext, \u0026mycpu()-\u003econtext); mycpu()-\u003eintena = intena; } scheduler函数寻找要调度的进程，调用switch保存调度器线程的寄存器，恢复选择运行的线程的寄存器继续执行。 void scheduler(void) { struct proc *p; struct cpu *c = mycpu(); c-\u003eproc = 0; for(;;){ // 打开中断避免死锁 intr_on(); int nproc = 0; for(p = proc; p \u003c \u0026proc[NPROC]; p++) { acquire(\u0026p-\u003elock); if(p-\u003estate != UNUSED) { nproc++; } if(p-\u003estate == RUNNABLE) { p-\u003estate = RUNNING; c-\u003eproc = p; swtch(\u0026c-\u003econtext, \u0026p-\u003econtext); c-\u003eproc = 0; } release(\u0026p-\u003elock); } ... } } 最后从swtch-\u003esched-\u003eyield-\u003eusertrap，最后返回到用户空间执行。 ","date":"2022-11-29","objectID":"/mit-6.s081-lab7-thread/:1:2","tags":["操作系统"],"title":"MIT 6.S081 Lab7 Thread","uri":"/mit-6.s081-lab7-thread/"},{"categories":["6.S081"],"content":"实验内容 ","date":"2022-11-29","objectID":"/mit-6.s081-lab7-thread/:2:0","tags":["操作系统"],"title":"MIT 6.S081 Lab7 Thread","uri":"/mit-6.s081-lab7-thread/"},{"categories":["6.S081"],"content":"Uthread: switching between threads (moderate) 本实验需要为用户级线程系统设计上下文切换机制，可以参考xv6进程切换 定义用来存储寄存器信息的context // user/uthread.c struct thread_context{ uint64 ra; //返回地址 uint64 sp; //内核栈指针 //Caller Saved Register会被编译器保存在当前的栈上 //只需要保存Callee Saved Register uint64 s0; uint64 s1; uint64 s2; uint64 s3; uint64 s4; uint64 s5; uint64 s6; uint64 s7; uint64 s8; uint64 s9; uint64 s10; uint64 s11; }; struct thread { char stack[STACK_SIZE]; /* the thread's stack */ int state; /* FREE, RUNNING, RUNNABLE */ struct thread_context context; }; 添加汇编代码进行被切换线程context的保存和切换线程context的恢复 // user/uthread_switch.S thread_switch: sd ra, 0(a0) sd sp, 8(a0) sd s0, 16(a0) sd s1, 24(a0) sd s2, 32(a0) sd s3, 40(a0) sd s4, 48(a0) sd s5, 56(a0) sd s6, 64(a0) sd s7, 72(a0) sd s8, 80(a0) sd s9, 88(a0) sd s10, 96(a0) sd s11, 104(a0) ld ra, 0(a1) ld sp, 8(a1) ld s0, 16(a1) ld s1, 24(a1) ld s2, 32(a1) ld s3, 40(a1) ld s4, 48(a1) ld s5, 56(a1) ld s6, 64(a1) ld s7, 72(a1) ld s8, 80(a1) ld s9, 88(a1) ld s10, 96(a1) ld s11, 104(a1) ret /* return to ra */ 修改thread_schedule函数 void thread_schedule(void) { ... if (current_thread != next_thread) { ... thread_switch((uint64)\u0026t-\u003econtext, (uint64)\u0026current_thread-\u003econtext); } ... } 修改thread_create函数 void thread_create(void (*func)()) { ... t-\u003econtext.ra = (uint64)func; t-\u003econtext.sp = (uint64)(t-\u003estack + STACK_SIZE); } ","date":"2022-11-29","objectID":"/mit-6.s081-lab7-thread/:2:1","tags":["操作系统"],"title":"MIT 6.S081 Lab7 Thread","uri":"/mit-6.s081-lab7-thread/"},{"categories":["6.S081"],"content":"Using threads (moderate) 该实验在多线程环境下存在不一致情况，代码通过头插法将key-value键值对插入到对应的BUCKET中，两个线程同时对同一个BUCKET操作会造成数据覆盖。需要对插入操作加锁进行限制。 // notxv6/ph.c ... pthread_mutex_t lock; double now() ... static void put(int key, int value) { ... else { // the new is new. pthread_mutex_lock(\u0026lock); insert(key, value, \u0026table[i], table[i]); pthread_mutex_unlock(\u0026lock); } } ... int main(int argc, char *argv[]) { ... tha = malloc(sizeof(pthread_t) * nthread); pthread_mutex_init(\u0026lock, NULL); ... } ","date":"2022-11-29","objectID":"/mit-6.s081-lab7-thread/:2:2","tags":["操作系统"],"title":"MIT 6.S081 Lab7 Thread","uri":"/mit-6.s081-lab7-thread/"},{"categories":["6.S081"],"content":"Barrier(moderate) 该实验需要实现屏障，保证所有线程到达才开启下一个round static void barrier() { ... pthread_mutex_lock(\u0026bstate.barrier_mutex); if (++bstate.nthread \u003c nthread) { pthread_cond_wait(\u0026bstate.barrier_cond, \u0026bstate.barrier_mutex); } else { bstate.nthread = 0; bstate.round++; pthread_cond_broadcast(\u0026bstate.barrier_cond); } pthread_mutex_unlock(\u0026bstate.barrier_mutex); } ","date":"2022-11-29","objectID":"/mit-6.s081-lab7-thread/:2:3","tags":["操作系统"],"title":"MIT 6.S081 Lab7 Thread","uri":"/mit-6.s081-lab7-thread/"},{"categories":["6.S081"],"content":"MIT 6.S801实验6","date":"2022-11-22","objectID":"/mit-6.s081-lab6-cow/","tags":["操作系统"],"title":"MIT 6.S081 Lab6 COW","uri":"/mit-6.s081-lab6-cow/"},{"categories":["6.S081"],"content":"课程知识 ","date":"2022-11-22","objectID":"/mit-6.s081-lab6-cow/:1:0","tags":["操作系统"],"title":"MIT 6.S081 Lab6 COW","uri":"/mit-6.s081-lab6-cow/"},{"categories":["6.S081"],"content":"中断 ​ 中断是操作系统异常控制流的一种。中断由外部I/O设备触发，请求CPU进行处理。和系统调用，page fault一样，发生中断时，操作系统也需要保护现场，处理中断，中断处理程序完成之后，在返回当前指令继续执行。xv6通过PLIC(Platform Level Interrupt Control) 处理设备中断，来自外部设备的中断首先会到达PLIC，PLIC会将中断路由到某个CPU的核进行处理。 ​ 当一个设备在不可预知的时间需要注意时，中断是有意义的。但是中断有很高的CPU开销。网络和磁盘控制器的高速设备，需要使用一些技巧减少中断需求。比如可以对整批传入或传出的请求发出单个中断。另一个技巧驱动程序完全禁用中断，通过轮询方式，定期检查设备是否需要注意。如果设备执行操作非常快，轮询是有意义的，但是如果设备大部分空闲，轮询会浪费CPU时间。一些驱动程序根据当前设备负载在轮询和中断之间动态切换。 ","date":"2022-11-22","objectID":"/mit-6.s081-lab6-cow/:1:1","tags":["操作系统"],"title":"MIT 6.S081 Lab6 COW","uri":"/mit-6.s081-lab6-cow/"},{"categories":["6.S081"],"content":"驱动 ​ 设备驱动程序用来管理设备，驱动可以执行设备操作，处理中断，和等待设备I/O的进程进行交互。大部分设备驱动可以分为上下两部分，上半部分要求硬件执行操作，在进程的内核线程运行，通过系统调用进行调用，如read和write，设备完成操作后，引发中断，下半部分即为中断处理程序，执行操作。 ","date":"2022-11-22","objectID":"/mit-6.s081-lab6-cow/:1:2","tags":["操作系统"],"title":"MIT 6.S081 Lab6 COW","uri":"/mit-6.s081-lab6-cow/"},{"categories":["6.S081"],"content":"控制台I/O ​ xv6中，控制台驱动程序通过连接到RISC-V的UART串口硬件接受用户键入的字符，控制台驱动程序一次累积一行输入，使用read系统调用从控制台获取输入行。UART（Universal asynchronous receiver-transmitter）即通用异步收发传输器。UART硬件是一组内存映射的控制寄存器，通过load和store特定内存即可完成对硬件的控制。在xv6中，UART的内存映射地址起始于0x10000000，有几个宽度为一字节的UART控制寄存器。xv6的main函数调用consoleinit来初始化UART硬件。UART对接收到的每个字节的输入生成一个接收中断，对发送完的每个字节的输出生成一个发送完成中断。 ​ 当用户输入一个字符时，UART硬件要求RISC-V发出一个中断，从而激活xv6的陷阱处理程序。陷阱处理程序调用devintr，它查看RISC-V的scause寄存器，发现中断来自外部设备。通过PLIC查看发生中断的设备，如果是UART，devintr调用uartintr。uartintr从UART硬件读取所有等待输入的字符，并将它们交给consoleintr，它不会等待字符，因为未来的输入将引发一个新的中断。consoleintr在cons.buf中积累输入字符，直到一整行到达。当换行符到达时，consoleintr唤醒一个等待的consoleread。consoleread将监视cons.buf中的一整行，将其复制到用户空间，并返回到用户空间。 ​ write系统调用对控制台的写入最终会调用uartputc函数，设备会维护输出缓冲uart_tx_buf，因此写进程不需要等待UART完成发送。uartputc将字符加入缓冲区后，调用uartstart函数开始传输之后返回，唯一的等待情况是缓冲区已满。每当UART发送一个字节后，就会产生一次中断。uartintr函数会调用uartstart函数判断传输是否完成，未完成就开始传输下一个缓冲的字符。因此，当进程写入多个字符时，第一个字节会通过uartputc调用uartstart进行传输，之后的字节将会被uartintr调用的uartstart进行传输。 ​ 控制台I/O需要通过UART驱动程序对读取UART控制寄存器，一次只能读取一个字节，并且数据会将传入的数据先拷贝的内核缓冲区，再拷贝到用户空间，无法在高数据速率下使用。需要高速移动大量数据的设备通常使用直接内存访问，DMA方式能够直接在用户空间缓冲区和设备硬件之间移动数据。DMA设备的驱动程序将在RAM中准备数据，然后使用对控制寄存器的单次写入来告诉设备处理准备好的数据。DMA广泛使用在磁盘和网络I/O。 ","date":"2022-11-22","objectID":"/mit-6.s081-lab6-cow/:1:3","tags":["操作系统"],"title":"MIT 6.S081 Lab6 COW","uri":"/mit-6.s081-lab6-cow/"},{"categories":["6.S081"],"content":"实验内容 ","date":"2022-11-22","objectID":"/mit-6.s081-lab6-cow/:2:0","tags":["操作系统"],"title":"MIT 6.S081 Lab6 COW","uri":"/mit-6.s081-lab6-cow/"},{"categories":["6.S081"],"content":"Implement copy-on write (hard) ​ 本实验是实现COW机制，即copy-on-write写时拷贝，将子进程对父进程的内存拷贝，推迟到子进程实际需要物理内存时再进行物理页面的分配和复制。在COW中， fork()只为子进程创建一个页表，子进程的页表项指向父进程的物理页面。父进程和子进程中的所有用户PTE标记为不可写。当任一进程试图写入其中一个COW页时，CPU将强制产生页面错误。page fault处理程序为出错进程分配一页物理内存，将原始页复制到新页中，并修改出错进程中的相关PTE指向新的页面，将PTE标记为可写。 在页表项中定义COW标志位 // kernel/riscv.h #define PTE_C (1L \u003c\u003c 8) 为每个物理页面设置一个引用计数，进行初始化，在最后一个PTE对它的引用撤销时释放 // kernel/kalloc.c struct { struct spinlock lock; int cnt[PHYSTOP \u003e\u003e 12]; } kref; ... void kinit() { initlock(\u0026kmem.lock, \"kmem\"); initlock(\u0026kref.lock, \"kref\"); freerange(end, (void*)PHYSTOP); } ... void freerange(void *pa_start, void *pa_end) { ... for(; p + PGSIZE \u003c= (char*)pa_end; p += PGSIZE) { kref.cnt[(uint64)p / PGSIZE] = 1; kfree(p); } } // kernel/kalloc.c void * kfree(void *pa) { ... acquire(\u0026kref.lock); kref.cnt[(uint64)pa \u003e\u003e 12]--; if(kref.cnt[(uint64)pa \u003e\u003e 12] != 0) { release(\u0026kref.lock); return; } release(\u0026kref.lock); r = (struct run*)pa; ... } void * kalloc(void) { struct run *r; acquire(\u0026kmem.lock); r = kmem.freelist; if(r) { kmem.freelist = r-\u003enext; acquire(\u0026kref.lock); kref.cnt[(uint64)r \u003e\u003e 12] = 1; release(\u0026kref.lock); } release(\u0026kmem.lock); ... } 添加addref两个函数，用来添加引用计数 // kernel/defs.h void addkref(uint64); // kernel/kalloc.c void addkref(uint64 pa) { if(((uint64)pa % PGSIZE) != 0 || (char*)pa \u003c end || (uint64)pa \u003e= PHYSTOP) return; acquire(\u0026kref.lock); kref.cnt[pa \u003e\u003e 12]++; release(\u0026kref.lock); } 修改uvmcopy，子进程的PTE需要指向父进程来代替为子进程分配新的物理页面 // kernel/vm.c int uvmcopy(pagetable_t old, pagetable_t new, uint64 sz) { pte_t *pte; uint64 pa, i; uint flags; for(i = 0; i \u003c sz; i += PGSIZE){ if((pte = walk(old, i, 0)) == 0) panic(\"uvmcopy: pte should exist\"); if((*pte \u0026 PTE_V) == 0) panic(\"uvmcopy: page not present\"); pa = PTE2PA(*pte); flags = PTE_FLAGS(*pte); if(flags \u0026 PTE_W) { flags = (flags | PTE_C) \u0026 ~PTE_W; *pte = PA2PTE(pa) | flags; } addkref(pa); if(mappages(new, i, PGSIZE, pa, flags) != 0){ goto err; } } ... } 添加cowalloc函数，用来分配cow物理页面 // kernel/defs.h int cowalloc(pagetable_t, uint64); // kernel/vm.c int cowalloc(pagetable_t pagetable, uint64 va) { uint64 pa; pte_t *pte; uint flags; if (va \u003e= MAXVA) return -1; va = PGROUNDDOWN(va); pte = walk(pagetable, va, 0); if (pte == 0 || (*pte \u0026 PTE_V) == 0) return -1; pa = PTE2PA(*pte); flags = PTE_FLAGS(*pte); if (flags \u0026 PTE_C) { char *mem = kalloc(); if (mem == 0) return -1; memmove(mem, (char*)pa, PGSIZE); flags = (flags \u0026 ~PTE_C) | PTE_W; *pte = PA2PTE((uint64)mem) | flags; kfree((void*)pa); return 0; } return 0; } 修改usertrap，处理page fault，分配物理页面 // kernel/trap.c void usertrap(void) { ... if(r_scause() == 8){ ... } else if(r_scause() == 13 || r_scause() == 15) { uint64 va = r_stval(); if (va \u003e= MAXVA ||(va \u003c= PGROUNDDOWN(p-\u003etrapframe-\u003esp) \u0026\u0026 va \u003e= PGROUNDDOWN(p-\u003etrapframe-\u003esp) - PGSIZE) || cowalloc(p-\u003epagetable, va) != 0) p-\u003ekilled = 1; } else if((which_dev = devintr()) != 0){ ... } 修改copyout函数，在遇到page fault时，分配物理页面 // kernel/vm.c int copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len) { uint64 n, va0, pa0; while(len \u003e 0){ va0 = PGROUNDDOWN(dstva); if (cowalloc(pagetable, va0) != 0) { return -1; } pa0 = walkaddr(pagetable, va0); ... } ","date":"2022-11-22","objectID":"/mit-6.s081-lab6-cow/:2:1","tags":["操作系统"],"title":"MIT 6.S081 Lab6 COW","uri":"/mit-6.s081-lab6-cow/"},{"categories":["6.S081"],"content":"MIT 6.S801实验5","date":"2022-11-15","objectID":"/mit-6.s081-lab5-lazy/","tags":["操作系统"],"title":"MIT 6.S081 Lab5 Traps","uri":"/mit-6.s081-lab5-lazy/"},{"categories":["6.S081"],"content":"课程知识 ","date":"2022-11-15","objectID":"/mit-6.s081-lab5-lazy/:1:0","tags":["操作系统"],"title":"MIT 6.S081 Lab5 Traps","uri":"/mit-6.s081-lab5-lazy/"},{"categories":["6.S081"],"content":"Page Fault ​ page fault即页面错误异常，当CPU无法将虚拟地址转化为物理地址时，会生成page fault。RISC-V有三种页面错误：读页面错误、写页面错误和指令执行页面错误。page fault和其他异常一样，也使用和系统调用相同的trap机制，从用户空间切换到内核空间。对page fault的处理需要三个寄存器：STVAL，SCAUSE，SEPC，分别存储发生page fault的虚拟地址，发生page fault的原因和发生page fault的用户空间地址。RISC-V中所有SCAUSE的值： ","date":"2022-11-15","objectID":"/mit-6.s081-lab5-lazy/:1:1","tags":["操作系统"],"title":"MIT 6.S081 Lab5 Traps","uri":"/mit-6.s081-lab5-lazy/"},{"categories":["6.S081"],"content":"使用Page Fault Lazy page Allocation ​ 当系统分配内存时，最终会调用sbrk函数，sbrk会扩大进程的heap的上边界，通过分配指定大小的物理内存，并将这些内存映射到用户程序的地址空间来扩大堆内存。sbrk函数默认是eager allocation，一旦调用了，内核会立即分配应用程序所需要的物理内存。带来的一个问题是，应用程序倾向申请多余自己所需要的内存，但是有部分内存永远也用不到，造成内存的浪费。 ​ lazy allocation将实际的内存分配延迟到发生page fault时才进行。在page fault处理函数中分配物理页面，并映射到用户程序的地址空间。sbrk并不进行实际的内存分配，而只是改变进程的p-\u003esz，当发生page fault时虚拟地址位于原p-\u003esz和新p-\u003esz之间时，为进程分配一个内存页。lazy allocations实行按需分配，可以减少内存的浪费，但是处理一次page fault需要用户态到内核态之间的切换，一个切换需要执行大量的store指令存取寄存器，会有时间性能的损耗。 Zero Fill On Demand ​ 一个程序的地址空间，会包含堆区，栈区，BSS区域，data区域和text区域，当编译器生成二进制文件时，编译器会填充这三个区域，text区域是程序的指令，data区域存放初始化的全局变量，BSS区域存放未被初始化或者初始化为0的全局变量。C程序的内存布局： ​ BSS段会有多个page来表示，所有page的内容均为0。我们只需要分配一个物理页面，将这个物理页面映射到所有程序的BSS段。需要设置PTE为只读，当我们需要尝试修改BSS的一个page，就会触发page fault，重新分配一个全0的物理页面，并映射到对应的虚拟地址。Zero可以节省内存，同时只需要分配一个全0物理页面，加快的程序的启动。 Copy On Write Fork ​ 当执行fork函数时，会创建一个子进程，并且会为子进程分配物理内存，使得子进程和父进程拥有相同的地址空间。但是子进程通常在fork之后，会立即调用exec，替换进程的物理内存。将刚刚分配的page释放掉，造成性能损耗。也不能直接让父子进程共享物理内存，父进程和子进程对共享堆栈的写入会造成进程奔溃。 ​ COW Fork让父子进程共享所有物理页面，但所有物理页面映射为只读。将父进程和子进程的PTE都设置为只读，当父进程或者子进程想要修改页面时，会触发page fault。page fault处理函数会分配一个新的物理页面，映射到该进程，并将PTE设置为可读写。我们需要在页表项中添加一项标志位，用来标识一个COW页面，用来区分正常的对只读地址写数据和对COW页面写数据。 ​ 引入COW Fork后，多个进程的虚拟地址都映射到了同一个物理页面，需要引入引用计数统计page，当我们释放虚拟page时，物理page引用计数减一，当page引用计数为0时，即可释放该物理页面。 Demand Paging ​ 执行exec，操作系统会加载程序内存的text区域和data区域，以eager allocation的方式加载到内存存在一定弊端，程序的二进制文件从磁盘加载到内存代价很高，需要大量I/O操作，data区域大小远小于分配大小，并不需要通过eager方式进行分配。demand paging 在程序执行的时候才进行真正的分配。 ​ demand paging为text区域和data区域分配好地址段，将PTE的有效位置为0，但并不分配真正的物理页面。应用程序从地址0向上增长，在执行时，地址0的指令触发page fault，page fault处理函数会从二进制文件中加载数据到内存，再将内存page映射到进程虚拟地址。若text区域和data区域大于真实物理内存，可以通过页面置换算法进行page淘汰。 Memory Mapped Files ​ memory mapped files将完整或者部分文件加载进内存，mmap将特定文件描述符的特定位置的数据映射到进程虚拟地址，就可以通过内存地址来读写文件。通过以lazy allocation的方式，并不会将文件从磁盘拷贝到内存，mmap借助VMA结构记录文件描述符，偏移量等元数据信息，用来保存虚拟地址对应的文件内容，当进程触发page fault的虚拟地址位于VMA内，操作系统才从磁盘中加载数据到内存，并映射到虚拟地址。 ​ ","date":"2022-11-15","objectID":"/mit-6.s081-lab5-lazy/:1:2","tags":["操作系统"],"title":"MIT 6.S081 Lab5 Traps","uri":"/mit-6.s081-lab5-lazy/"},{"categories":["6.S081"],"content":"实验内容 ","date":"2022-11-15","objectID":"/mit-6.s081-lab5-lazy/:2:0","tags":["操作系统"],"title":"MIT 6.S081 Lab5 Traps","uri":"/mit-6.s081-lab5-lazy/"},{"categories":["6.S081"],"content":"Eliminate allocation from sbrk() (easy) 该实验需要将实际调用堆内存代码删除，sbrk()只标记分配内存，并不真正进行分配 // kernel/sysproc.c uint64 sys_sbrk(void) { int addr; int n; if(argint(0, \u0026n) \u003c 0) return -1; addr = myproc()-\u003esz; myproc()-\u003esz += n ; return addr; } ","date":"2022-11-15","objectID":"/mit-6.s081-lab5-lazy/:2:1","tags":["操作系统"],"title":"MIT 6.S081 Lab5 Traps","uri":"/mit-6.s081-lab5-lazy/"},{"categories":["6.S081"],"content":"Lazy allocation (moderate) 本实验在上一个实验的基础上进行，上一个实验中sbrk()并不真正分配内存，进程在访问虚拟地址，进行虚拟地址到物理地址的转化时，会出现page fault，我们需要在出现page fault时进行内存分配 处理page fault，当出现对虚拟地址的读和写错误时进行页面分配 // kernel/trap.c void usertrap(void) { ... if(r_scause() == 8){ ... } else if(r_scause() == 13 || r_scause() == 15) { uint64 va = r_stval(); va = PGROUNDDOWN(va); char *pa = kalloc(); if(pa == 0) { p-\u003ekilled = 1; } else { memset(pa, 0, PGSIZE); if(mappages(p-\u003epagetable, va, PGSIZE, (uint64)pa, PTE_W|PTE_X|PTE_R|PTE_U) != 0){ kfree(pa); p-\u003ekilled = 1; } } } else if((which_dev = devintr()) != 0){ ... } 修改uvmunmap函数，在sys_sbrk()中标记分配的内存可能并没有分配实际的物理内存，因此在接触虚拟地址和物理地址映射时需要跳过 // kernel/vm.c void uvmunmap(pagetable_t pagetable, uint64 va, uint64 npages, int do_free) { ... for(a = va; a \u003c va + npages*PGSIZE; a += PGSIZE){ if((pte = walk(pagetable, a, 0)) == 0) continue; if((*pte \u0026 PTE_V) == 0) continue; if(PTE_FLAGS(*pte) == PTE_V) panic(\"uvmunmap: not a leaf\"); if(do_free){ uint64 pa = PTE2PA(*pte); kfree((void*)pa); } *pte = 0; } } ","date":"2022-11-15","objectID":"/mit-6.s081-lab5-lazy/:2:2","tags":["操作系统"],"title":"MIT 6.S081 Lab5 Traps","uri":"/mit-6.s081-lab5-lazy/"},{"categories":["6.S081"],"content":"Lazytests and Usertests (moderate) 本实验需要完成提示中的要求，进一步完善物理内存的延迟分配，通过测试程序 处理sbrk()参数为负数的情况，需要在为负数时调用uvmdealloc()函数 // kernel/sysproc.c uint64 sys_sbrk(void) { ... if(n \u003c 0) { if(addr + n \u003c 0) return -1; if(uvmdealloc(myproc()-\u003epagetable, addr, addr + n) != addr + n) return -1; } addr = myproc()-\u003esz; ... } 判断出现page fault的虚拟地址是否合法，排除高于sbrk()分配虚拟内存地址和低于用户栈的虚拟内存地址 // kernel/trap.c void usertrap(void) { ... else if(r_scause() == 13 || r_scause() == 15) { ... if(va \u003e= p-\u003esz || va \u003c= PGROUNDDOWN(p-\u003etrapframe-\u003esp)) { p-\u003ekilled = 1; } else { char *pa = kalloc(); ... } fork()调用uvmcopy子进程会拷贝父进程物理内存，父进程物理内存并没有全部分配，需要跳过没有分配的部分 // kernel/vm.c int uvmcopy(pagetable_t old, pagetable_t new, uint64 sz) { ... for(i = 0; i \u003c sz; i += PGSIZE){ if((pte = walk(old, i, 0)) == 0) continue; if((*pte \u0026 PTE_V) == 0) continue; ... } ... } 进程调用read和write系统调用时，不会通过页表硬件进行地址翻译，而是通过walkaddr完成虚拟地址到物理地址的转化，我们需要在copyin和copyout中进行page fault处理 // kernel/vm.c int copyin(pagetable_t pagetable, char *dst, uint64 srcva, uint64 len) { ... while(len \u003e 0){ va0 = PGROUNDDOWN(srcva); pa0 = walkaddr(pagetable, va0); if(pa0 == 0) { if(va0 \u003e= myproc()-\u003esz || va0 \u003c myproc()-\u003etrapframe-\u003esp) { return -1; } else { pa0 = (uint64) kalloc(); if (pa0 == 0) { myproc()-\u003ekilled = 1; } else { memset((void *)pa0, 0, PGSIZE); va0 = PGROUNDDOWN(va0); if(mappages(myproc()-\u003epagetable, va0, PGSIZE, pa0, PTE_W|PTE_R|PTE_U) != 0) { kfree((void *)pa0); myproc()-\u003ekilled = 1; } } } } ... } return 0; } // kernel/vm.c int copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len) { ... while(len \u003e 0){ va0 = PGROUNDDOWN(dstva); pa0 = walkaddr(pagetable, va0); if(pa0 == 0) { if(va0 \u003e= myproc()-\u003esz || va0 \u003c myproc()-\u003etrapframe-\u003esp) { return -1; } else { pa0 = (uint64) kalloc(); if (pa0 == 0) { myproc()-\u003ekilled = 1; } else { memset((void *)pa0, 0, PGSIZE); va0 = PGROUNDDOWN(va0); if(mappages(myproc()-\u003epagetable, va0, PGSIZE, pa0, PTE_W|PTE_R|PTE_U) != 0) { kfree((void *)pa0); myproc()-\u003ekilled = 1; } } } } ... } return 0; } ","date":"2022-11-15","objectID":"/mit-6.s081-lab5-lazy/:2:3","tags":["操作系统"],"title":"MIT 6.S081 Lab5 Traps","uri":"/mit-6.s081-lab5-lazy/"},{"categories":["6.S081"],"content":"MIT 6.S801实验4","date":"2022-11-08","objectID":"/mit-6.s081-lab4-traps/","tags":["操作系统"],"title":"MIT 6.S081 Lab4 Traps","uri":"/mit-6.s081-lab4-traps/"},{"categories":["6.S081"],"content":"课程知识 ","date":"2022-11-08","objectID":"/mit-6.s081-lab4-traps/:1:0","tags":["操作系统"],"title":"MIT 6.S081 Lab4 Traps","uri":"/mit-6.s081-lab4-traps/"},{"categories":["6.S081"],"content":"RISC和CISC xv6运行在RISC-V处理器上，RISC-V是精简指令集(RISC)，和传统以x86-64为代表的复杂指令集(CISC)存在一下区别： RISC拥有更少的指令数量，CISC需要向后兼容，指令数目会不断变大 RISC指令功能简单，可以减少CPU执行时间，CISC指令功能复杂，指令周期较长 ","date":"2022-11-08","objectID":"/mit-6.s081-lab4-traps/:1:1","tags":["操作系统"],"title":"MIT 6.S081 Lab4 Traps","uri":"/mit-6.s081-lab4-traps/"},{"categories":["6.S081"],"content":"栈 xv6每次调用函数，系统都会创建一个栈帧Stack Frame，系统通过移动栈指针Stack Pointer来完成Stack Frame的空间分配。栈从高地址向低地址增长，Stack Poiner需要向下移动来创建一个新的Stack Frame。xv6栈结构图如下所示： 每个Stack Frame均包含Retrun Address和指向前一个Frame的指针，同时会保存寄存器和一些本地变量，系统维护两个寄存器SP(Stack Pointer)和FP(Frame Pointer)，SP指向当前Frame的底部，FP指向当前Frame的顶部，可以通过FP找到每个栈中的固定位置的Return Address和指向前一个Frame的指针，保证函数正确调用和返回。 ","date":"2022-11-08","objectID":"/mit-6.s081-lab4-traps/:1:2","tags":["操作系统"],"title":"MIT 6.S081 Lab4 Traps","uri":"/mit-6.s081-lab4-traps/"},{"categories":["6.S081"],"content":"xv6的trap机制 从用户空间到内核空间的切换被称为陷入trap，trap是异常控制流的一种，trap分为三类 系统调用，异常和设备中断。 xv6的trap处理过程，以系统调用为例： 用户请求系统调用，将系统调用号写入a7寄存器，并调用ecall指令。 # kernel/usys.S ... .global write write: li a7, SYS_write ecall ret ... ecall指令执行内容： ecall将状态从用户态设置为内核态 将pc值保存在sepc寄存器中， 设置好stvec，即trapline page的起始位置uservec函数，跳转stvec寄存器指向的指令 ecall指令并不会切换页表，为了能在用户页表下可以执行uservec，用户页表必须包含uservec的映射。xv6利用trampoline page实现，trampoline page在用户空间和内核空间都映射到了相同的虚拟地址。trampoline page， 即蹦床页面很形象，即通过该页面从用户空间跳到了内核空间。 执行uservec函数 uservec执行的第一步是交换a0和SSCARTCH的值。SSCARTCH寄存器保存trapframe page的地址，这样我们就得到了trapframe page的地址，可以将32个寄存器保存在trapframe page中了。 xv6就每一个进程的trapframe分配一个页面，并安排它映射在用户虚拟地址的固定位置，位于trampoline page的下一个页面。 # kernel/trampoline.S # swap a0 and sscratch # so that a0 is TRAPFRAME csrrw a0, sscratch, a0 # save the user registers in TRAPFRAME sd ra, 40(a0) sd sp, 48(a0) sd gp, 56(a0) sd tp, 64(a0) sd t0, 72(a0) sd t1, 80(a0) ... sd t6, 280(a0) # save the user a0 in p-\u003etrapframe-\u003ea0 csrr t0, sscratch sd t0, 112(a0) 接下来加载内核栈到sp，确保内核程序正常运行；保存CPU的id到tp，用来获取当前进程；向t0写入usertrap的指针；向t1写入内核页表的地址并与SATP寄存器进行交换，完成页表的切换，跳转到usertrap执行 # kernel/trampoline.S # restore kernel stack pointer from p-\u003etrapframe-\u003ekernel_sp ld sp, 8(a0) # make tp hold the current hartid, from p-\u003etrapframe-\u003ekernel_hartid ld tp, 32(a0) # load the address of usertrap(), p-\u003etrapframe-\u003ekernel_trap ld t0, 16(a0) # restore kernel page table from p-\u003etrapframe-\u003ekernel_satp ld t1, 0(a0) csrw satp, t1 sfence.vma zero, zero # a0 is no longer valid, since the kernel page # table does not specially map p-\u003etf. # jump to usertrap(), which does not return jr t0 执行usertrap函数 首先设置寄存器，更改STVEC寄存器，指向内核空间trap处理代码的位置；将SEPC保存到trampframe中，防止程序执行过程中切换到另一个程序，另一个程序再调用系统调用导致SEPC数据被覆盖。 // kernel/trap.c w_stvec((uint64)kernelvec); struct proc *p = myproc(); // save user program counter. p-\u003etrapframe-\u003eepc = r_sepc(); 针对trap的来源进行分析，如果陷阱来自系统调用syscall会处理它，根据系统调用号查找相应的系统调用函数，执行真正的系统调用，将返回值保存在tramframe的a0寄存器中；如果是设备中断，devintr会处理；否则它是一个异常，内核会杀死错误进程。最后调用usertrapret函数。 // kernel/trap.c if(r_scause() == 8){ // system call if(p-\u003ekilled) exit(-1); // sepc points to the ecall instruction, // but we want to return to the next instruction. p-\u003etrapframe-\u003eepc += 4; // an interrupt will change sstatus \u0026c registers, // so don't enable until done with those registers. intr_on(); syscall(); } else if((which_dev = devintr()) != 0){ // ok } else { printf(\"usertrap(): unexpected scause %p pid=%d\\n\", r_scause(), p-\u003epid); printf(\" sepc=%p stval=%p\\n\", r_sepc(), r_stval()); p-\u003ekilled = 1; } if(p-\u003ekilled) exit(-1); 执行usertrapret，内核需要为返回内核空间做准备 关闭中断，更新STVEC寄存器，指向uservec；设置kernel page table的指针，内核栈指针，usertrap函数的指针到trapframe中；设置SSTATUS寄存器，便于下一次从用户空间到内核空间的跳转，并恢复程序计数器pc的值。 // kernel/trap.c p-\u003etrapframe-\u003ekernel_satp = r_satp(); // kernel page table p-\u003etrapframe-\u003ekernel_sp = p-\u003ekstack + PGSIZE; // process's kernel stack p-\u003etrapframe-\u003ekernel_trap = (uint64)usertrap; p-\u003etrapframe-\u003ekernel_hartid = r_tp(); // hartid for cpuid() ... w_sepc(p-\u003etrapframe-\u003eepc); 最后通过调用userret函数，将trapframe page的地址和用户页表的地址作为参数存储在a0，a1寄存器中，返回到用户空间的时候才能完成page table的切换。 uint64 fn = TRAMPOLINE + (userret - trampoline); ((void (*)(uint64,uint64))fn)(TRAPFRAME, satp); 最后执行userret 首先切换页表 csrw satp, a1 sfence.vma zero, zero # put the saved user a0 in sscratch, so we # can swap it with our a0 (TRAPFRAME) in the last step. ld t0, 112(a0) csrw sscratch, t0 接着恢复用户寄存器，最后调用sret，sret会打开中断，更改内核态为用户态，跳转pc指向的指令执行用户程序。 ","date":"2022-11-08","objectID":"/mit-6.s081-lab4-traps/:1:3","tags":["操作系统"],"title":"MIT 6.S081 Lab4 Traps","uri":"/mit-6.s081-lab4-traps/"},{"categories":["6.S081"],"content":"实验内容 ","date":"2022-11-08","objectID":"/mit-6.s081-lab4-traps/:2:0","tags":["操作系统"],"title":"MIT 6.S081 Lab4 Traps","uri":"/mit-6.s081-lab4-traps/"},{"categories":["6.S081"],"content":"RISC-V assembly (easy) RISC-V使用a0~a7共8个寄存器存储函数参数，若函数参数超过8个则需要存储在内存中，通过代码可以看出，13保存在a2寄存器中 # user/call.asm 24: 4635 li a2,13 通过代码看出，函数并没有对f调用 # user/call.asm 26: 45b1 li a1,12 printf的函数地址是0x640 auipc指令将高20位立即数左移12位加上pc后，存入ra寄存器，0x00000097对应的高20位左移12位之后为0x0，pc寄存器为0x30，因此ra寄存器的值为0x30，加上偏移量即为0x30 + 0x600(1536) = 0x630 # user/call.asm 30: 00000097 auipc ra,0x0 34: 600080e7 jalr 1536(ra) # 640 \u003cprintf\u003e printf的jalr之后的寄存器ra值是0x38 jalr指令当前PC+4保存在rd中，因此jalr之后寄存器ra值为0x34 + 0x4 = 0x38 程序输出HE110 World，大端需改成0x726c6400 57616不需要改 大端将高位存放在低地址，小段将高位存放在高地址 大端存储0x00646c72 00-64-6c-72 小段存储0x00646c72 72-6c-64-00 没有参数传a2寄存器，y显示的值是原来a2寄存器的值。 ","date":"2022-11-08","objectID":"/mit-6.s081-lab4-traps/:2:1","tags":["操作系统"],"title":"MIT 6.S081 Lab4 Traps","uri":"/mit-6.s081-lab4-traps/"},{"categories":["6.S081"],"content":"Backtrace(moderate) backtrace实验需要打印函数执行过程中每个stack frame的地址。stack frame的格式已经介绍。 首先根据提示添加函数添加到kernel/riscv.h中，获取保存在s0寄存器的帧指针fp。 static inline uint64 r_fp() { uint64 x; asm volatile(\"mv %0, s0\" : \"=r\" (x) ); return x; } 实现backtrace函数，首先获取帧指针fp，并获取页栈页面的顶部地址，接着就打印fp的地址，并通过frame中指向前一个frame的指针获取前一个frame。直到到达页顶部，即已经打印了所有stack frame的地址。（需要在kernel/defs.h中声明） // kernel/print.c void backtrace() { uint64 fp = r_fp(); uint64 stack_base = PGROUNDUP(fp); printf(\"backtrace:\\n\"); while(fp \u003c stack_base) { printf(\"%p\\n\", *((uint64*)(fp - 8))); fp = *((uint64*)(fp - 16)); } } ","date":"2022-11-08","objectID":"/mit-6.s081-lab4-traps/:2:2","tags":["操作系统"],"title":"MIT 6.S081 Lab4 Traps","uri":"/mit-6.s081-lab4-traps/"},{"categories":["6.S081"],"content":"Alarm(Hard) alarm实验要求我们在进程使用CPU的时间内，xv6定期向进程发出警报。 首先添加系统调用，并在user/usys.pl中添加 // user/user.h int sigalarm(int ticks, void (*handler)()); int sigreturn(void); 首先在进程结构体中添加字段，并在allocproc进行初始化和freeproc回收 // kernel/proc.h struct proc { ... int interval; //警报间隔 int tickcnt; //距离上一次调用经过了多少个时钟 uint64 handler; //警报处理函数 ... } // kernel/proc.c static struct proc* allocproc(void) { ... p-\u003einterval = 0; p-\u003etickcnt = 0; p-\u003ehandler = 0; // An empty user page table. p-\u003epagetable = proc_pagetable(p); ... } // kernel/proc.c static void freeproc(struct proc *p) { ... p-\u003einterval = 0; p-\u003etickcnt = 0; p-\u003ehandler = 0; } 实现真正的sys_sigalarm函数和sys_sigreturn函数 // kernel/syscall.h #define SYS_sigalarm 22 #define SYS_sigreturn 23 // kernel/syscall.c ... extern uint64 sys_sigalarm(void); extern uint64 sys_sigreturn(void); static uint64 (*syscalls[])(void) = { ... [SYS_sigalarm] sys_sigalarm, [SYS_sigreturn] sys_sigreturn, }; // kernel/sysproc.c uint64 sys_sigalarm(void) { if(argint(0, \u0026myproc()-\u003einterval) \u003c 0) return -1; if(argaddr(1, \u0026myproc()-\u003ehandler) \u003c 0) return -1; return 0; } uint64 sys_sigreturn(void) { return 0; } 修改usertrap，进程警报间隔期满时，设置pc值为警报处理函数handler的地址，同时清除时钟计数器 // kernel/trap.c if(which_dev == 2) { p-\u003etickcnt++; if(p-\u003eflag == 0 \u0026\u0026 p-\u003etickcnt == p-\u003einterval) { p-\u003etickcnt = 0; p-\u003etrapframe-\u003eepc = p-\u003ehandler; } yield(); } 我们在test0测试中系统调用返回时返回的handler的地址，会导致无法回到用户程序之中，我们需要在test1/test2中处理正确返回到用户代码和防止重复调用的问题。我们需要在进程结构体中再加入两个字段，并在allocproc进行初始化和freeproc回收。 // kernel/proc.h struct proc { ... int interval; //警报间隔 int tickcnt; //距离上一次调用经过了多少个时钟 uint64 handler; //警报处理函数 int flag; struct trapframe *alarm_trapframe; ... } 添加保存进程陷阱帧p-\u003etrapframe到p-\u003ealarm_trapframe，并置flag为1，防止handler重复调用 // kernel/trap.c if(which_dev == 2) { p-\u003etickcnt++; if(p-\u003eflag == 0 \u0026\u0026 p-\u003etickcnt == p-\u003einterval) { memmove(p-\u003ealarm_trapframe, p-\u003etrapframe, sizeof(struct trapframe)); p-\u003etickcnt = 0; p-\u003etrapframe-\u003eepc = p-\u003ehandler; p-\u003eflag = 1; } yield(); } 实现sys_sigreturn函数，当hanler调用sigreturn()时恢复陷阱帧，同时将flag置零，保证下一个handler能够调用。 // kernel/sysproc.c uint64 sys_sigreturn(void) { memmove(myproc()-\u003etrapframe, myproc()-\u003ealarm_trapframe, sizeof(struct trapframe)); myproc()-\u003eflag = 0; return 0; } ","date":"2022-11-08","objectID":"/mit-6.s081-lab4-traps/:2:3","tags":["操作系统"],"title":"MIT 6.S081 Lab4 Traps","uri":"/mit-6.s081-lab4-traps/"},{"categories":["6.S081"],"content":"MIT 6.S801实验3","date":"2022-10-30","objectID":"/mit-6.s081-lab3-pgtbl/","tags":["操作系统"],"title":"MIT 6.S081 Lab3 Pgtbl","uri":"/mit-6.s081-lab3-pgtbl/"},{"categories":["6.S081"],"content":"课程内容 ","date":"2022-10-30","objectID":"/mit-6.s081-lab3-pgtbl/:1:0","tags":["操作系统"],"title":"MIT 6.S081 Lab3 Pgtbl","uri":"/mit-6.s081-lab3-pgtbl/"},{"categories":["6.S081"],"content":"虚拟内存 实现操作系统的强隔离性，需要硬件的支持。除了分离用户态内核态的设计，让用户程序与内核相互独立，还有虚拟内存机制的设计，让用户程序之间相互独立，每个进程拥有自己的地址空间。引入虚拟内存之后，每个进程拥有独立的地址空间，用户无需直接操作物理内存，只需使用该进程的虚拟地址，虚拟内存会将虚拟地址转化为物理地址，从而避免出现一个进程覆盖另一个进程的内存地址。 ","date":"2022-10-30","objectID":"/mit-6.s081-lab3-pgtbl/:1:1","tags":["操作系统"],"title":"MIT 6.S081 Lab3 Pgtbl","uri":"/mit-6.s081-lab3-pgtbl/"},{"categories":["6.S081"],"content":"页表 页表是虚拟内存机制的核心，完成从虚拟地址到物理地址之间的映射。页表由页表项组成，页表项保存虚拟页号和物理页号映射。 页表是以页为粒度进行管理的，若以每个地址为粒度，则地址总线为64bit的机器需要管理2^64个地址，内存会被页表耗尽。 xv6中使用64位虚拟地址的低39bit，其中高27bit为页表索引，低12bit为页内偏移量offset，即页面大小为4KB。使用物理地址的低56bit，物理页号为其中高44bit，低12bit对应offset。通过页表索引得到物理块号，加上offset即为对应的物理地址。 页表保存在内存中，27bit的页表索引需要2^27个页表项来保存，每个页表项8B，需要占用大量连续内存，为此在xv6中引入三级页表。每个页表页拥有512个页表项，每个页表项都包含下一个页表页的物理地址，最低一级页表项对应的物理页号，加上低12bit的偏移量即为最终物理地址。 相比于单级页表： 节省内存，内核不必为整个目录分配连续的内存页面。 按需分配，只有在需要用到该页表索引对应的物理页时才进行分配 缺点在于必须从内存中加载三个PTE将虚拟地址转换成物理地址，需要访问内存三次，需要借助快表TLB提升效率。 TLB会保存虚拟地址到物理地址的映射关系，根据程序局部性原理，大大减少访存次数，提高寻址效率 xv6页表项为64bit，低10bit为各种标志位，包括读，写，执行等权限，中间44bit对应物理页号，高10bit保留。 内核页表 xv6为每个进程维护一个页表。描述每个进程的地址空间，还会维护一个单独的描述内核地址空间的页表，即内核页表。内核页表映射整个物理内存，内核设置了虚拟地址等于物理地址的映射关系，直接映射简化了读取或写入物理内存的内核代码。如通过虚拟地址查找物理地址时，先提取下一级页表的物理地址，然后将该物理地址作为虚拟地址获取下一级的页表项。 内核页表中除了直接映射之外，还存在特殊映射，即一个物理地址对应两个虚拟地址。 蹦床页面： 蹦床页面被映射了两次，包括直接映射和虚拟地址空间的顶部 内核栈页面 每个内核栈会被映射到高地址，便于在其虚拟地址下映射一个保护页(guard page)，内核栈溢出会引发一个异常，若栈溢出不会覆盖其他内存， 用户页表 xv6为每个进程维护一个用户页表，保存用户空间虚拟地址和物理地址之间的映射。 ","date":"2022-10-30","objectID":"/mit-6.s081-lab3-pgtbl/:1:2","tags":["操作系统"],"title":"MIT 6.S081 Lab3 Pgtbl","uri":"/mit-6.s081-lab3-pgtbl/"},{"categories":["6.S081"],"content":"实验内容 ","date":"2022-10-30","objectID":"/mit-6.s081-lab3-pgtbl/:2:0","tags":["操作系统"],"title":"MIT 6.S081 Lab3 Pgtbl","uri":"/mit-6.s081-lab3-pgtbl/"},{"categories":["6.S081"],"content":"Print a page table (easy) 该实验需要我们打印所有已分配的页表，由于xv6采用三级页表，因此我们需要通过递归的方式按级打印页表项地址和下一级页表的物理地址，参考/kernel/vm.c中的freewalk函数。 // kernel/vm.c void vmprinthelper(pagetable_t pagetable, int k) { if(k == 3) return; for(int i = 0; i \u003c 512; i++){ pte_t pte = pagetable[i]; if(pte \u0026 PTE_V){ printf(\"..\"); for(int j = 0; j \u003c k; j++) { printf(\" ..\"); } printf(\"%d: pte %p pa %p\\n\", i, pte, PTE2PA(pte)); vmprinthelper((pagetable_t)PTE2PA(pte), k + 1); } } } void vmprint(pagetable_t pagetable) { printf(\"page table %p\\n\", pagetable); vmprinthelper(pagetable, 0); } ","date":"2022-10-30","objectID":"/mit-6.s081-lab3-pgtbl/:2:1","tags":["操作系统"],"title":"MIT 6.S081 Lab3 Pgtbl","uri":"/mit-6.s081-lab3-pgtbl/"},{"categories":["6.S081"],"content":"A kernel page table per process (hard) xv6会为每一个用户进程提供一个用户页表，该页表包含用户内存的映射，而内核页表不包含这些映射，当内核需要使用在系统调用中传递的用户指针时，用户地址在内核中无效，需要先将其转化为物理地址，导致效率降低，我们的目标是允许内核直接解引用用户指针。 本实验需要先为每一个进程维护一个内核页表，进程在内核中执行时使用它自己的内核页表，同时需要为每个进程在内核页表中分配内核栈，最后需要将所有调用kernel_pagetable的地方替换为当前进程的内核页表。 在进程结构体中添加内核页表kernel_pagetable属性 // kernel/proc.h struct proc { ... pagetable_t kernel_pagetable; ... }; 实现kvmcreate()函数，在新进程创建时调用，参考kvminit() // kernel/vm.c pagetable_t kvmcreate() { pagetable_t user_kernel_pagetable = (pagetable_t) kalloc(); memset(user_kernel_pagetable, 0, PGSIZE); uvmmap(user_kernel_pagetable, UART0, UART0, PGSIZE, PTE_R | PTE_W); uvmmap(user_kernel_pagetable, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W); uvmmap(user_kernel_pagetable, CLINT, CLINT, 0x10000, PTE_R | PTE_W); uvmmap(user_kernel_pagetable, PLIC, PLIC, 0x400000, PTE_R | PTE_W); uvmmap(user_kernel_pagetable, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X); uvmmap(user_kernel_pagetable, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W); uvmmap(user_kernel_pagetable, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X); return user_kernel_pagetable; } 将procinit函数中在为每个进程在内核页表中分配内核栈的操作转移到allocproc函数中，需要注意的是我们需要在当前进程的kernel_pagetable分配内核栈，为此我们需要设置一个uvmmap函数，指明在哪个页表添加，参考kvmmap函数 // kernel/proc.c void procinit(void) { struct proc *p; initlock(\u0026pid_lock, \"nextpid\"); for(p = proc; p \u003c \u0026proc[NPROC]; p++) { initlock(\u0026p-\u003elock, \"proc\"); // Allocate a page for the process's kernel stack. // Map it high in memory, followed by an invalid // guard page. // char *pa = kalloc(); // if(pa == 0) // panic(\"kalloc\"); // uint64 va = KSTACK((int) (p - proc)); // kvmmap(va, (uint64)pa, PGSIZE, PTE_R | PTE_W); // p-\u003ekstack = va; } kvminithart(); } // kernel/proc.c static struct proc* allocproc(void) { ... p-\u003epagetable = proc_pagetable(p); p-\u003ekernel_pagetable = kvmcreate(); if(p-\u003epagetable == 0){ freeproc(p); release(\u0026p-\u003elock); return 0; } char *pa = kalloc(); if(pa == 0) panic(\"kalloc\"); uint64 va = KSTACK((int) (p - proc)); uvmmap(p-\u003ekernel_pagetable, va, (uint64)pa, PGSIZE, PTE_R | PTE_W); p-\u003ekstack = va; ... } // kernel/vm.c void uvmmap(pagetable_t pagetable, uint64 va, uint64 pa, uint64 sz, int perm) { if(mappages(pagetable, va, sz, pa, perm) != 0) panic(\"uvmmap\"); } 修改schduler函数，将该进程的内核页表kernel_pagetable装载进satp寄存器执行 // kernel/proc.c ... w_satp(MAKE_SATP(p-\u003ekernel_pagetable)); sfence_vma(); swtch(\u0026c-\u003econtext, \u0026p-\u003econtext); ... 实现释放进程内核页表函数freewalk_kernel_pagetable函数，参考freewalk函数，需要注意的是，每个进程的内核页表都映射了整个物理内存和进程本身的内核栈，内核栈单独free，我们需要避免free最低一级页表对应的物理块。（需要在kernel/defs.h中声明） // kernel/vm.c void freewalk_kernel_pagetable(pagetable_t pagetable) { for(int i = 0; i \u003c 512; i++){ pte_t pte = pagetable[i]; if((pte \u0026 PTE_V)){ pagetable[i] = 0; //只要最低一级页表项中这些标志位可能非0 if ((pte \u0026 (PTE_R|PTE_W|PTE_X)) == 0) { uint64 child = PTE2PA(pte); freewalk_kernel_pagetable((pagetable_t)child); } } } kfree((void*)pagetable); } 在freeproc函数中调用释放进程内核页表freewalk_kernel_pagetable函数 // kernel/proc.c if(p-\u003ekernel_pagetable) { freewalk_kernel_pagetable(p-\u003ekernel_pagetable); } 我们还需要修改kvmpa函数，将kernel_pagetable换成当前进程的内核页表。该函数将栈上虚拟地址转化为物理地址 // kernel/vm.c uint64 kvmpa(uint64 va) { uint64 off = va % PGSIZE; pte_t *pte; uint64 pa; pte = walk(myproc()-\u003ekernel_pagetable, va, 0); if(pte == 0) panic(\"kvmpa\"); if((*pte \u0026 PTE_V) == 0) panic(\"kvmpa\"); pa = PTE2PA(*pte); return pa+off; } ","date":"2022-10-30","objectID":"/mit-6.s081-lab3-pgtbl/:2:2","tags":["操作系统"],"title":"MIT 6.S081 Lab3 Pgtbl","uri":"/mit-6.s081-lab3-pgtbl/"},{"categories":["6.S081"],"content":"Simplify copyin/copyinstr（hard） 为了避免通过遍历进程页表来获取物理地址，我们需要将用户空间的映射添加到该进程的内核页表中。从而使得copyin和copyinstr可以直接操作用户指针。由于内核的虚拟内存从0开始的底部有一块空闲的地址，我们可以将映射添加到该部分，需要注意的是用户进程的最大大小限制为小于内核的最低虚拟地址。即0xC000000，PLIC寄存器的地址。 实现u2kvmcopy函数，将进程的页表复制到进程的内核页表中，需要注意的是我们需要将用户页表中的PTE_U标志位去掉，以便可以在内核中执行。参考uvmcopy函数 // kernel/vm.c void u2kvmcopy(pagetable_t pagetable, pagetable_t kernelpt, uint64 oldsz, uint64 newsz){ pte_t *pte_from, *pte_to; oldsz = PGROUNDUP(oldsz); for (uint64 i = oldsz; i \u003c newsz; i += PGSIZE){ if((pte_from = walk(pagetable, i, 0)) == 0) panic(\"u2kvmcopy: pte does not exist\"); if((pte_to = walk(kernelpt, i, 1)) == 0) panic(\"u2kvmcopy: pte walk failed\"); uint64 pa = PTE2PA(*pte_from); uint flags = (PTE_FLAGS(*pte_from)) \u0026 (~PTE_U); *pte_to = PA2PTE(pa) | flags; } } 在fork函数，exec函数和sbrk函数中添加对u2kvmcopy函数的调用，确保用户映射能够复制到进程的内核页表中。 // kernel/exec.c int exec(char *path, char **argv) { ... stackbase = sp - PGSIZE; u2kvmcopy(pagetable, p-\u003ekernel_pagetable, 0, sz); ... } // kernel/proc.c int fork(void) { ... u2kvmcopy(np-\u003epagetable, np-\u003ekernel_pagetable, 0, np-\u003esz); // copy saved user registers. *(np-\u003etrapframe) = *(p-\u003etrapframe); ... } // kernel/proc.c int growproc(int n) { ... if((sz = uvmalloc(p-\u003epagetable, sz, sz + n)) == 0) { return -1; } u2kvmcopy(p-\u003epagetable, p-\u003ekernel_pagetable, sz - n, sz); ... } 在userinit函数中将第一个进程的用户页表添加进该进程的内核页表。 // kernel/proc.c void userinit(void) { ... p-\u003esz = PGSIZE; u2kvmcopy(p-\u003epagetable, p-\u003ekernel_pagetable, 0, p-\u003esz); ... } 替换copyin和copyinstr（需要将copyin_new和copyinstr_new添加进kernel/defs.h）。 // kernel/vm.c int copyin(pagetable_t pagetable, char *dst, uint64 srcva, uint64 len) { return copyin_new(pagetable, dst, srcva, len); } int copyinstr(pagetable_t pagetable, char *dst, uint64 srcva, uint64 max) { return copyinstr_new(pagetable, dst, srcva, max); } 为了确保用户进程的最大大小限制为小于内核的最低虚拟地址，需要在sbrk加入限制 // kernel/proc.c int growproc(int n) { ... if(n \u003e 0){ if (PGROUNDUP(sz + n) \u003e= PLIC){ return -1; } ... } ... } ","date":"2022-10-30","objectID":"/mit-6.s081-lab3-pgtbl/:2:3","tags":["操作系统"],"title":"MIT 6.S081 Lab3 Pgtbl","uri":"/mit-6.s081-lab3-pgtbl/"},{"categories":["6.S081"],"content":"MIT 6.S801实验2","date":"2022-10-15","objectID":"/mit-6.s081-lab2-syscall/","tags":["操作系统"],"title":"MIT 6.S081 Lab2 Syscall","uri":"/mit-6.s081-lab2-syscall/"},{"categories":["6.S081"],"content":"课程知识 ","date":"2022-10-15","objectID":"/mit-6.s081-lab2-syscall/:1:0","tags":["操作系统"],"title":"MIT 6.S081 Lab2 Syscall","uri":"/mit-6.s081-lab2-syscall/"},{"categories":["6.S081"],"content":"什么是操作系统 操作系统是管理下层硬件资源，并为上层软件提供统一的抽象接口的软件。如果没有操作系统，进程可以直接运行在系统资源之上，甚至可以直接操作内存。操作系统可以保证系统资源的强隔离性，以实现多路复用和内存隔离。 具体来说，当我们用户空间有多个进程时，进程的调度需要靠进程自己释放和获得CPU资源，若出现崩溃则其他进程均无法运行。而有了操作系统，这些进程会被操作系统根据特定的调度算法进行执行，不会因为一个进程的崩溃而收到影响。 同样，用户程序可以直接对物理内存进行操作，进程可能会覆盖里一个进程的内存地址，导致程序崩溃。而有了操作系统，用户只需提供虚拟地址，OS会自动映射到物理地址进行操作，将和硬件的直接操作交给OS。 ","date":"2022-10-15","objectID":"/mit-6.s081-lab2-syscall/:1:1","tags":["操作系统"],"title":"MIT 6.S081 Lab2 Syscall","uri":"/mit-6.s081-lab2-syscall/"},{"categories":["6.S081"],"content":"用户态和内核态 用户空间的程序运行在用户态，内核空间的程序运行在内核态。用户态下CPU可运行普通权限的指令，内核态下CPU可运行特权指令，特权指令包括直接操纵硬件的指令和设置保护的指令，例如设置页表寄存器，关闭时钟中断等 处理器中有一个标志位，1表示用户态，0为内核态。从用户态到内核态的切换是通过ECALL来实现的，ECALL接受一个数字作为参数。调用ECALL指令，ECALL会跳转到内核一个特定的由内核控制的位置。syscall函数接收到ECALL的参数，会调用实际的系统调用。 #/user/usys.pl #usys.pl会被makefile调用，会被编译成usys.S汇编文件，当用户调用这些用户态程序时，便会进入usy.S执行 #可以看到用户态程序通过ecall指令跳转到内核，并且传入参数表示想要调用的系统调用 sub entry { my $name = shift; print \".global $name\\n\"; print \"${name}:\\n\"; print \" li a7, SYS_${name}\\n\"; print \" ecall\\n\"; print \" ret\\n\"; } #/user/usys.S #编译生成的fork()的汇编代码 #include \"kernel/syscall.h\" .global fork fork: li a7, SYS_fork ecall ret ECALL指令提升硬件特权级别，并将PC更改为内核定义的入口点，入口点的代码切换到内核栈，执行实现系统调用的内核指令，当系统调用完成时，内核切换回用户栈，并通过调用sret指令返回用户空间，该指令降低了硬件特权级别，并在系统调用指令刚结束时恢复执行用户指令。 每个进程有两个栈区，用户栈区和内核栈区，当进程执行用户指令时，只有它的用户栈在使用，它的内核栈是空的。当进程进入内核时，内核代码在进程的内核栈上执行，用户栈仍然包含保存的数据，只是不处于活动状态。 ","date":"2022-10-15","objectID":"/mit-6.s081-lab2-syscall/:1:2","tags":["操作系统"],"title":"MIT 6.S081 Lab2 Syscall","uri":"/mit-6.s081-lab2-syscall/"},{"categories":["6.S081"],"content":"宏内核和微内核 宏内核：整个操作系统的代码都运行在kernel mode中，集成度高，性能很好，缺点是内核很大，出现安全性问题的可能性也更大 微内核：微内核，内核只保留最基本的代码，如IPC，页表以及分时复用CPU等，大部分运行在用户空间。当我们需要调用这些系统调用时，通过内核作为中介进行调用。内核更安全，但是性能不行，需要两次内核空间到用户空间的切换。同时由于各部分隔离，共享page cache变得难以实现。 ","date":"2022-10-15","objectID":"/mit-6.s081-lab2-syscall/:1:3","tags":["操作系统"],"title":"MIT 6.S081 Lab2 Syscall","uri":"/mit-6.s081-lab2-syscall/"},{"categories":["6.S081"],"content":"xv6开机过程 计算机上电，初始化并运行一个存储在ROM的引导加载程序，引导加载程序将xv6内核加载到内存中(0x80000000) CPU从_entry(kernel/entry.S)开始运行xv6，_entry指令设置栈区，有了栈区，_entry调用C代码start start设置内核态，时钟编程产生计时器中断，设置返回地址为main函数地址，禁用虚拟内存。通过调用mert进入main函数 main()初始化设备页表，调用userinit()创建第一个用户进程，通过系统调用exec()重新进入内核，exec返回到init进程用户空间 init进程创建控制台，用文件描述符0，1，2打开控制台文件，并启动一个shell ","date":"2022-10-15","objectID":"/mit-6.s081-lab2-syscall/:1:4","tags":["操作系统"],"title":"MIT 6.S081 Lab2 Syscall","uri":"/mit-6.s081-lab2-syscall/"},{"categories":["6.S081"],"content":"xv6系统调用过程 用户程序调用系统调用函数，将系统调用号存入a7寄存器，调用ecall指令。 ecall指令会进入内核定义的入口点，切换内核栈运行，依次执行uservec、usertrap和syscall。 syscall会获取trapframe中存储在a7寄存器的值，即系统调用号，执行对应的系统调用函数。 处理结束之后需要将返回值放入trapframe的a0寄存器，调用sret，用户空间会获得系统调用的返回结果。 ","date":"2022-10-15","objectID":"/mit-6.s081-lab2-syscall/:1:5","tags":["操作系统"],"title":"MIT 6.S081 Lab2 Syscall","uri":"/mit-6.s081-lab2-syscall/"},{"categories":["6.S081"],"content":"实验内容 实验二和实验一相反，已经帮我们实现好了用户程序，需要涉及到内核的修改和扩展，要求我们实现系统调用，保证用户程序正常运行。 ","date":"2022-10-15","objectID":"/mit-6.s081-lab2-syscall/:2:0","tags":["操作系统"],"title":"MIT 6.S081 Lab2 Syscall","uri":"/mit-6.s081-lab2-syscall/"},{"categories":["6.S081"],"content":"System call tracing（moderate） system call tracing实验要求我们实现一个可以追踪调用情况的系统调用，我们需要创建一个sys_trace的系统调用，该系统接受一个mask参数，若mask第n位为1，即表示我们需要显示该系统调用被调用情况，打印出进程id、系统调用的名称和返回值。为此，我们需要在每次系统调用结束之后，检查该进程mask对应位上是否为1，即调用是否需要打印。 首先添加系统调用号 // kernel/syscall.h ... #define SYS_trace 22 在函数指针数组syscalls[]中加入sys_trace // kernel/syscall.c static uint64 (*syscalls[])(void) = { ... [SYS_trace] sys_trace, } 在进程结构体中添加mask属性，保存需要追踪的系统调用 // kernel/proc.h struct proc { ... int mask; } 修改fork(),确保派生的任何子进程也能进行追踪 // kernel/proc.c int fork(void) { ... np-\u003emask = p-\u003emask; release(\u0026np-\u003elock); return pid; } 实现sys_trace() // kernel/sysproc.c uint64 sys_trace(void) { int n; struct proc *p = myproc(); if(argint(0, \u0026n) \u003c 0) return -1; p-\u003emask = n; return 0; } 修改syscall(void) // kernel/syscall.c //保存系统调用的名称，便于打印 static char* names[23] = { \"fork\", \"exit\", \"wait\", \"pipe\", \"read\", \"kill\",\"exec\", \"fstat\", \"chdir\", \"dup\", \"getpid\", \"sbrk\", \"sleep\", \"uptime\", \"open\", \"write\", \"mknod\", \"unlink\", \"link\", \"mkdir\", \"close\", \"trace\", \"sysinfo\" }; void syscall(void) { int num; struct proc *p = myproc(); num = p-\u003etrapframe-\u003ea7; if(num \u003e 0 \u0026\u0026 num \u003c NELEM(syscalls) \u0026\u0026 syscalls[num]) { p-\u003etrapframe-\u003ea0 = syscalls[num](); if(p-\u003emask \u003e\u003e num \u0026 1) printf(\"%d: syscall %s -\u003e %d\\n\", p-\u003epid, names[num - 1], p-\u003etrapframe-\u003ea0); } else { printf(\"%d %s: unknown sys call %d\\n\", p-\u003epid, p-\u003ename, num); p-\u003etrapframe-\u003ea0 = -1; } } ","date":"2022-10-15","objectID":"/mit-6.s081-lab2-syscall/:2:1","tags":["操作系统"],"title":"MIT 6.S081 Lab2 Syscall","uri":"/mit-6.s081-lab2-syscall/"},{"categories":["6.S081"],"content":"Sysinfo（moderate） sysinfo实验要求我们实现显示运行信息的系统调用，包括显示空闲内存的字节数和进程数。空闲内存的字节数的统计参考kalloc.c，进程数的统计参考proc.c 首先添加系统调用号 // kernel/syscall.h ... #define SYS_sysinfo 23 在函数指针数组syscalls[]中加入sys_trace // kernel/syscall.c static uint64 (*syscalls[])(void) = { ... [SYS_sysinfo] sys_sysinfo, } 统计空闲内存的字节数（需要在kernel/defs.h中声明） // kernel/kalloc.c int freecount(void) { int freecnt = 0; struct run *r; r = kmem.freelist; while(r) { freecnt++; r = r-\u003enext; } return freecnt * PGSIZE; } 统计进程数（需要在kernel/defs.h中声明） // kernel/proc.c int proccount(void) { int proccnt = 0; struct proc *p; for(p = proc; p \u003c \u0026proc[NPROC]; p++) { if(p-\u003estate != UNUSED) { proccnt++; } } return proccnt; } 实现sys_info() uint64 sys_sysinfo(void) { uint64 addr; struct sysinfo si; if(argaddr(0, \u0026addr) \u003c 0) return -1; si.freemem = freecount(); si.nproc = proccount(); //将sysinfo结构体复制回用户空间 if(copyout(myproc()-\u003epagetable, addr, (char *)\u0026si, sizeof(si)) \u003c 0) return -1; return 0; } ","date":"2022-10-15","objectID":"/mit-6.s081-lab2-syscall/:2:2","tags":["操作系统"],"title":"MIT 6.S081 Lab2 Syscall","uri":"/mit-6.s081-lab2-syscall/"},{"categories":["6.S081"],"content":"MIT 6.S801 实验1","date":"2022-10-11","objectID":"/mit-6.s081-lab1-util/","tags":["操作系统"],"title":"MIT 6.S081 Lab1 Util","uri":"/mit-6.s081-lab1-util/"},{"categories":["6.S081"],"content":"6.S081是MIT开放的操作系统课程，围绕xv6展开教学和实验。xv6是简化的类UNIX系统，采用精简指令集RISC-V架构，运行在RISC-V微处理器上，实验可以在QEMU上模拟运行，QEMU是一个硬件模拟器，用来模拟CPU和计算机，可以虚拟不同的硬件平台架构，在没有特定RISC-V硬件下也能运行xv6。本实验是基于6.S081 / Fall 2020。 ","date":"2022-10-11","objectID":"/mit-6.s081-lab1-util/:0:0","tags":["操作系统"],"title":"MIT 6.S081 Lab1 Util","uri":"/mit-6.s081-lab1-util/"},{"categories":["6.S081"],"content":"课程知识 ","date":"2022-10-11","objectID":"/mit-6.s081-lab1-util/:1:0","tags":["操作系统"],"title":"MIT 6.S081 Lab1 Util","uri":"/mit-6.s081-lab1-util/"},{"categories":["6.S081"],"content":"内核的概念 内核提供操作系统的基本功能，在开机时被加载进内存并常驻内存。内核不是进程，就是一段代码加数据的二进制文件。可以看成是一组系统调用的集合，不能主动执行，只能通过系统调用来为其他程序提供服务。例如用户要执行系统调用open()打开一个文件，就会由用户态切换为内核态，执行内核提供的sys_open()打开文件，返回fd。 内核组成： 管理用户进程的数据结构，如进程结构体，页表 管理各种硬件资源的数据结构，如抽象出的磁盘，I/O设备 各个模块提供的系统调用，如内存模块，文件系统，进程间通信(IPC) ","date":"2022-10-11","objectID":"/mit-6.s081-lab1-util/:1:1","tags":["操作系统"],"title":"MIT 6.S081 Lab1 Util","uri":"/mit-6.s081-lab1-util/"},{"categories":["6.S081"],"content":"xv6的进程表示 Xv6进程由用户空间和内核空间组成，用户空间包含指令，数据和堆栈，内核空间包含每个进程状态。Xv6采用分时机制，保证多个进程并发执行。当一个进程没有执行时，Xv6保存CPU寄存器，并在下一次运行该进程时恢复它们。 // kernel/proc.h // Xv6进程结构体表示 struct proc { struct spinlock lock; // p-\u003elock must be held when using these: enum procstate state; // Process state struct proc *parent; // Parent process void *chan; // If non-zero, sleeping on chan int killed; // If non-zero, have been killed int xstate; // Exit status to be returned to parent's wait int pid; // Process ID // these are private to the process, so p-\u003elock need not be held. uint64 kstack; // Virtual address of kernel stack uint64 sz; // Size of process memory (bytes) pagetable_t pagetable; // User page table struct trapframe *trapframe; // data page for trampoline.S struct context context; // 进程上下文，即寄存器内容 struct file *ofile[NOFILE]; // Open files struct inode *cwd; // Current directory char name[16]; // Process name (debugging) }; ","date":"2022-10-11","objectID":"/mit-6.s081-lab1-util/:1:2","tags":["操作系统"],"title":"MIT 6.S081 Lab1 Util","uri":"/mit-6.s081-lab1-util/"},{"categories":["6.S081"],"content":"常见的系统调用 fork() 一个进程可以使用fork系统调用创建一个新进程，子进程和父进程内存完全相同，在父进程中返回子进程的pid，在子进程中返回0,我们可以根据fork()返回值判断父子进程。子进程返回0，父进程返回子进程的pid。详见kernel/proc.c。 wait() 用来回收所有的子进程。wait()系统调用返回当前进程已退出子进程的PID，并将子进程的退出状态复制到传递给wait的地址, 0表示成功， 1表示失败，wait()会一直等待到子进程退出，若没有子进程，返回-1。如果我们由n个子进程，若想要等待所有的子进程都退出，父进程需要调用n次fork()。详见kernel/wait.c。 exec() 从文件系统中加载ELF格式的内存映像替换调用进程的内存，包含两个参数：文件名和字符串数组。exec()执行成功，它不向调用进程返回数据，而是使指令从ELF header中声明的程序入口开始执行，exec()一般配合fork()使用。详见kernel/exec.c。 ","date":"2022-10-11","objectID":"/mit-6.s081-lab1-util/:1:3","tags":["操作系统"],"title":"MIT 6.S081 Lab1 Util","uri":"/mit-6.s081-lab1-util/"},{"categories":["6.S081"],"content":"文件描述符 进程需要读写由内核管理的对象，包括文件，管道，设备等，文件描述符将这些对象之间的差异抽象出来，隐藏不同类型文件之间的差异，使用文件描述符统一进行I/O。举个例子，cat程序并不需要知道是从文件，管道还是设备读取，也不需要知道写入到控制台、文件还是设备。 每个进程都有一个从文件描述符表，默认0表示标准输入，1表示标准输出，2表示标准错误，每次打开一个新文件，**优先分配最小的未使用的文件描述符，**可以实现I/O重定向。 引用文件的每个文件描述符都有一个与之关联的偏移量，read每次从文件的偏移量开始读取数据，write类似，exec()会替换调用进程的内存，但是不会改变修改子进程的描述符，并且偏移量在父文件和子文件是共享的。 ","date":"2022-10-11","objectID":"/mit-6.s081-lab1-util/:1:4","tags":["操作系统"],"title":"MIT 6.S081 Lab1 Util","uri":"/mit-6.s081-lab1-util/"},{"categories":["6.S081"],"content":"管道 管道本质是一段内核缓冲区，一端用于读，一端用于写，可以作为一种进程间通信方式， p[0]负责读，p[1]负责写。 当读取端或写入端有多个文件描述符指向的时候。read会等待直到有新数据写入或者所有指向写入端的文件描述符都被关闭， write会等待直到有数据读出或者所有指向读取端的文件描述符都被关闭。 当管道的读端和写端没有指向的文件描述符时，管道会自动回收。同时相比于文件重定向，管道可以任意传递长的数据流，允许并行执行，且在进程间通讯时读写效率更高。 ","date":"2022-10-11","objectID":"/mit-6.s081-lab1-util/:1:5","tags":["操作系统"],"title":"MIT 6.S081 Lab1 Util","uri":"/mit-6.s081-lab1-util/"},{"categories":["6.S081"],"content":"实验内容 实验一并没有设计内核的修改和扩展，只是在用户空间利用xv6提供的系统调用完成一些公共程序。我们在接下来的实验中会用到以下系统调用： 系统调用 描述 int fork() 创建一个进程，父进程返回子进程PID，子进程返回0 int exit(int status) 终止当前进程，并将status报告给wait()函数，无返回 int wait(int *status) 等待一个子进程退出，status保存退出状态，返回子进程PID int getpid() 返回当前进程的PID int exec(char *file, char *argv[]) 加载一个文件并使用参数执行 int open(char* file, int flags) 打开一个文件，flags表示读/写，返回一个fd int close(int fd) 释放打开的文件fd int write(int fd, char *buf, int n) 从buf中写入n个字节到文件描述符fd， 返回n int read(int fd, char *buf, int n) 从fd中读取n个字节到buf中，返回读取的字节数 int pipe(int p[]) 创建一个管道，把读写文件描述符放在p[0]和p[1]中 int fstat(int fd, struct stat *st) 将打开文件fd的信息存入stat结构体中 int sleep(int n) 使CPU休眠n个节拍 ","date":"2022-10-11","objectID":"/mit-6.s081-lab1-util/:2:0","tags":["操作系统"],"title":"MIT 6.S081 Lab1 Util","uri":"/mit-6.s081-lab1-util/"},{"categories":["6.S081"],"content":"sleep (easy） sleep实验我们只需要xv6提供的int sleep(int)系统调用即可。 int main(int argc, char *argv[]) { if(argc \u003c 2) { fprintf(2, \"Usage: sleep number\\n\"); exit(1); } int n = atoi(argv[1]); sleep(n); exit(0); } ","date":"2022-10-11","objectID":"/mit-6.s081-lab1-util/:2:1","tags":["操作系统"],"title":"MIT 6.S081 Lab1 Util","uri":"/mit-6.s081-lab1-util/"},{"categories":["6.S081"],"content":"pingpong (easy) pingpong实验使用管道进行父子进程的通信。实验需要使用两个管道，分别负责父进程的发送和子进程的发送，需要注意阻塞问题，当使用fork()之后，父子进程的p[0]都指向读取端，p[1]均指向写入端。为此我们需要将多余的fd关闭，保证管道能被回收。 int main(int agrc, char *argv[]) { int pid; int p2c[2], c2p[2]; char buf[5]; pipe(p2c); pipe(c2p); pid = fork(); if(pid == 0) { close(p2c[1]); read(p2c[0], buf, 5); fprintf(2, \"%d: received %s\\n\", getpid(), buf); close(p2c[0]); close(c2p[0]); write(c2p[1], \"pong\", 5); close(c2p[1]); exit(0); } else { close(p2c[0]); write(p2c[1], \"ping\", 5); close(p2c[1]); close(c2p[1]); read(c2p[0], buf, 5); fprintf(2, \"%d: received %s\\n\", getpid(), buf); close(c2p[0]); wait((int *)0); } exit(0); } ","date":"2022-10-11","objectID":"/mit-6.s081-lab1-util/:2:2","tags":["操作系统"],"title":"MIT 6.S081 Lab1 Util","uri":"/mit-6.s081-lab1-util/"},{"categories":["6.S081"],"content":"primes (moderate)/(hard)) primes实验是一个有趣的利用父子进程求解素数问题。利用埃拉托色尼筛，父进程首先将2 ~35的素数放入管道中，fork()出子进程，读取管道中第一个数k，该数为素数，打印该数。并将管道中剩余的数全部取出，去掉k的倍数，剩余数存入管道，交给下一个子进程进行处理。直至管道为空。需要注意关闭没用的fd。 void primes(int *p) { int i, k, pid; int np[2]; if(read(p[0], \u0026k, 4) == 0) { close(p[0]); exit(0); } fprintf(2, \"prime %d\\n\", k); pipe(np); pid = fork(); if(pid == 0) { close(np[1]); primes(np); } else { close(p[1]); close(np[0]); while(read(p[0], \u0026i, 4) != 0) { if(i % k != 0) { write(np[1], \u0026i, 4); } } close(np[1]); close(p[0]); wait((int*)0); exit(0); } } int main(int argc, char *argv[]) { int i, pid; int p[2]; pipe(p); pid = fork(); if(pid == 0) { close(p[1]); primes(p); } else { close(p[0]); for(i = 2; i \u003c= 35; i++) { write(p[1], \u0026i, sizeof(int)); } close(p[1]); wait((int *)0); } exit(0); } ","date":"2022-10-11","objectID":"/mit-6.s081-lab1-util/:2:3","tags":["操作系统"],"title":"MIT 6.S081 Lab1 Util","uri":"/mit-6.s081-lab1-util/"},{"categories":["6.S081"],"content":"find (moderate) find实验用来查找当前路径下所有指定文件名的文件，需要返回文件全路径，参考user/ls.c中关于目录文件的读取，即可实现。 //获取不带路径的文件名 char* fmtname(char *path) { static char buf[DIRSIZ+1]; char *p; for(p=path+strlen(path); p \u003e= path \u0026\u0026 *p != '/'; p--) ; p++; if(strlen(p) \u003e= DIRSIZ) return p; memmove(buf, p, strlen(p)); *(buf + strlen(p))= 0; return buf; } void find(char* path, const char* filename) { char buf[512], *p; int fd; struct dirent de; struct stat st; if((fd = open(path, 0)) \u003c 0) { fprintf(2, \"find: cannot open %s\\n\", path); return; } if(fstat(fd, \u0026st) \u003c 0){ fprintf(2, \"find: cannot stat %s\\n\", path); close(fd); return; } switch(st.type){ case T_FILE: if(strcmp(fmtname(path), filename) == 0) { printf(\"%s\\n\", path); } break; case T_DIR: if(strlen(path) + 1 + DIRSIZ + 1 \u003e sizeof buf){ printf(\"ls: path too long\\n\"); break; } strcpy(buf, path); p = buf+strlen(buf); *p++ = '/'; while(read(fd, \u0026de, sizeof(de)) == sizeof(de)){ if(de.inum == 0 || strcmp(de.name, \".\") == 0 || strcmp(de.name, \"..\") == 0) continue; memmove(p, de.name, DIRSIZ); p[DIRSIZ] = 0; find(buf, filename); } break; } close(fd); } int main(int argc, char *argv[]) { if(argc \u003c 2) { fprintf(2, \"Usage: find path filename\\n\"); exit(1); } else if(argc == 2) { find(\".\", argv[1]); } else { find(argv[1], argv[2]); } exit(0); } ","date":"2022-10-11","objectID":"/mit-6.s081-lab1-util/:2:4","tags":["操作系统"],"title":"MIT 6.S081 Lab1 Util","uri":"/mit-6.s081-lab1-util/"},{"categories":["6.S081"],"content":"xargs (moderate) xargs实验是编写一个简化版UNIX的xargs程序。xargs命令的作用，是将标准输入转为命令行参数，需要配合管道使用。实现xargs首先需要读取标准输入中的字符串，并将字符串添加到xargs所要执行的程序参数列表最后作为参数。若读取到多行， 需要为每一行的都fork()一个子进程进行执行。 int main(int argc, char *argv[]) { int i; char *p, buf[512]; if(argc \u003c 2) { fprintf(2, \"Usage: xargs command args...\\n\"); exit(1); } if(read(0, buf, sizeof(buf)) == 0) { fprintf(2, \"no arguments\\n\"); exit(1); } p = buf; for(i = 0; buf[i] != 0; i++) { if(buf[i] == '\\n') { buf[i] = 0; if(fork() == 0) { argv[argc++] = p; argv[argc] = 0; exec(argv[1], argv + 1); exit(0); } else { p = buf + i + 1; wait((int *)0); } } } exit(0); } ","date":"2022-10-11","objectID":"/mit-6.s081-lab1-util/:2:5","tags":["操作系统"],"title":"MIT 6.S081 Lab1 Util","uri":"/mit-6.s081-lab1-util/"},{"categories":["leetcode"],"content":"Acwing算法基础课模板","date":"2021-07-10","objectID":"/algorithm_template/","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"Acwing算法基础课模板 ","date":"2021-07-10","objectID":"/algorithm_template/:0:0","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"排序 ","date":"2021-07-10","objectID":"/algorithm_template/:1:0","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"快速排序 void quick_sort(int q[], int l, int r) { if (l \u003e= r) return; int i = l - 1, j = r + 1, x = q[ l + r \u003e\u003e 1 ]; while(i \u003c j) { do i++ ; while(q[i] \u003c x); do j-- ; while(q[j] \u003e x); if(i \u003c j) swap(q[i],q[j]); } quick_sort(q, l, j); //只会出现i == j 或者 i = j + 1 情况 quick_sort(q, j+1, r); } ","date":"2021-07-10","objectID":"/algorithm_template/:1:1","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"归并排序 void merge_sort(int a[], int l, int r) { if(l\u003e=r) return; int mid = l+r \u003e\u003e 1; merge_sort(a,l,mid); merge_sort(a,mid+1,r); int k = 0, i = l, j = mid+1; while(i \u003c= mid \u0026\u0026 j \u003c= r) { if(a[i] \u003c= a[j]) tmp[k++] = a[i++]; else tmp[k++] = a[j++]; } while(i \u003c= mid) tmp[k++] = a[i++]; while(j \u003c= r) tmp[k++] = a[j++]; for(i = l, j = 0; i \u003c= r; i++, j++) a[i] = tmp[j]; } ","date":"2021-07-10","objectID":"/algorithm_template/:1:2","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"二分 ","date":"2021-07-10","objectID":"/algorithm_template/:2:0","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"整数二分 //先写check函数，想一下check如何更新更新区间，如果l = mid, 需要+1 int bsearch_1(int l, int r) { while(l \u003c r) { int mid = l+r \u003e\u003e 1; if(check(mid)) r = mid; else l = mid + 1; } return l; } int bsearch_2(int l, int r) { //区别在于当l = mid, 需要+1 while(l \u003c r) { int mid = l + r + 1 \u003e\u003e 1; if(check(mid)) l = mid; else r = mid - 1; } return l; } ","date":"2021-07-10","objectID":"/algorithm_template/:2:1","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"浮点数二分 double bsearch_3(double l, double r) { //eps 尽量比题目要求再高出两位，减少误差 while(r-l \u003e eps) { double mid = (l + r) / 2; if(check(mid)) r = mid; else l = mid; } return l; } ","date":"2021-07-10","objectID":"/algorithm_template/:2:2","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"高精度 ","date":"2021-07-10","objectID":"/algorithm_template/:3:0","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"高精度加法 vector\u003cint\u003e add(vector\u003cint\u003e\u0026 a, vector\u003cint\u003e\u0026 b) { vector\u003cint\u003e c; int t = 0; for(int i = 0; i \u003c a.size() || i \u003c b.size(); i++) { if(i \u003c a.size()) t += a[i]; if(i \u003c b.size()) t += b[i]; c.push_back(t % 10); t /= 10; } if(t) c.push_back(t); return c; } ","date":"2021-07-10","objectID":"/algorithm_template/:3:1","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"高精度减法 vector\u003cint\u003e sub(vector\u003cint\u003e \u0026A, vector\u003cint\u003e \u0026B) { vector\u003cint\u003e C; for (int i = 0, t = 0; i \u003c A.size(); i ++ ) { t = A[i] - t; if (i \u003c B.size()) t -= B[i]; C.push_back((t + 10) % 10); if (t \u003c 0) t = 1; else t = 0; } while (C.size() \u003e 1 \u0026\u0026 C.back() == 0) C.pop_back(); //去除前导0 return C; } ","date":"2021-07-10","objectID":"/algorithm_template/:3:2","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"高精度乘法 vector\u003cint\u003e mul(vector\u003cint\u003e \u0026A, int b) { vector\u003cint\u003e C; int t = 0; for (int i = 0; i \u003c A.size() || t; i ++ ) { if (i \u003c A.size()) t += A[i] * b; C.push_back(t % 10); t /= 10; } while (C.size() \u003e 1 \u0026\u0026 C.back() == 0) C.pop_back(); return C; } ","date":"2021-07-10","objectID":"/algorithm_template/:3:3","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"高精度除法 vector\u003cint\u003e div(vector\u003cint\u003e\u0026 A, int B, int\u0026 r) { vector\u003cint\u003e c; r = 0; //从最高位算 for(int i = A.size() - 1; i \u003e= 0 ;i--) { r = r * 10 + A[i]; c.push_back(r / B); r %= B; } reverse(c.begin(), c.end()); while(c.size() \u003e 1 \u0026\u0026 c.back() == 0) c.pop_back(); return c; } ","date":"2021-07-10","objectID":"/algorithm_template/:3:4","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"差分和前缀和 ","date":"2021-07-10","objectID":"/algorithm_template/:4:0","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"前缀和 //构造二维前缀和 s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i][j]; //获取二维前缀和 s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1]; ","date":"2021-07-10","objectID":"/algorithm_template/:4:1","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"差分 // a[i] = b[1] + b[2] + ... + b[i] void insert(int l, int r, int c) { a[l] += c; a[r + 1] -= c; } // 二维差分 void insert(int x1, int y1, int x2, int y2, int c) { a[x1][y1] += c; a[x2 + 1][y1] -= c; a[x1][y2 + 1] -= c; a[x2 + 1][y2 + 1] += c; } b[i][j] = b[i][j] + b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1]; ","date":"2021-07-10","objectID":"/algorithm_template/:4:2","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"双指针 //需要找到一些性质(单调性) 使得O(n^2)变为O(n) for(int i = 0, j = 0; i \u003c n; i++) { while(j \u003c i \u0026\u0026 check(i, j)) j++; } ","date":"2021-07-10","objectID":"/algorithm_template/:5:0","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"位运算 求第k位 n \u003e\u003e k \u0026 1; 返回最后一位1的位置 lowbit(n) n \u0026 -n ; ","date":"2021-07-10","objectID":"/algorithm_template/:6:0","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"离散化 //区间和 vector\u003cint\u003e alls; //存储所有离散化的值 sort(alls.begin(), alls.end()); //排序 alls.erase(unique(alls.begin(), alls.end()), alls.end()); //去重 int find(x) { int l = 0, r = alls.size() - 1; while(l \u003c r) { int mid = (l + r) \u003e\u003e 1; if(alls[mid] \u003e= x) r = mid; else l = mid + 1; } return r + 1; //便于求前缀和 } ","date":"2021-07-10","objectID":"/algorithm_template/:7:0","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"区间合并 void merge(vector\u003cpii\u003e \u0026segs) { vector\u003cpii\u003e res; sort(segs.begin(), segs.end()); int st = -2e9, ed = -2e9; for(auto seg : segs) { if(ed \u003c seg.first) { if(st != -2e9) res.push_back({st, ed}); st = seg.first, ed = seg.second; } else ed = max(ed, seg.second); } if(st != -2e9) res.push_back({st,ed}); segs = res; } ","date":"2021-07-10","objectID":"/algorithm_template/:8:0","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"数据结构 ","date":"2021-07-10","objectID":"/algorithm_template/:9:0","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"单链表 //主要应用 邻接表，存储图和树 int head, e[N], ne[N], idx; void init() { head = -1, idx = 0; } void add_to_head(int x) { e[idx] = x, ne[idx] = head, head = idx, idx ++; } //在下标为k的节点后添加 void add(int k, int x) { e[idx] = x, ne[idx] = ne[k], ne[k] = idx, idx ++; } //在下标为k的节点后删除 void remove(int k) { ne[k] = ne[ne[k]]; } ","date":"2021-07-10","objectID":"/algorithm_template/:9:1","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"双链表 //l[i] 节点i左边的点是 r[i] 节点i右边的点是 int e[N], l[N], r[N], idx; void init() { r[0] = 1, l[1] = 0; idx = 2; } //在下标为k的节点右边插入 void add(int k, int x) { e[idx] = x; r[idx] = r[k]; l[idx] = k; l[r[k]] = idx; r[k] = idx; idx ++; } //在下标为k的节点左边插入 void add(int l[k], int x); //删除下标为k的节点 void remove(int k) { l[r[k]] = l[k]; r[l[k]] = r[k]; } ","date":"2021-07-10","objectID":"/algorithm_template/:9:2","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"栈 //tt表示栈顶 int stk[N], tt; //插入 stk[++tt] = x; //弹出 tt--; //栈顶的值 stk[tt]; //判断栈是否为空 if(tt \u003e 0) {}; ","date":"2021-07-10","objectID":"/algorithm_template/:9:3","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"队列 int q[N], hh = 0, tt = -1; //插入 q[++tt] = x; //弹出 hh++ //判空 if(hh \u003c= tt) not empty //取出队头元素 q[hh]; ","date":"2021-07-10","objectID":"/algorithm_template/:9:4","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"单调栈 //常见模型：找出每个数左边离它最近的比它大/小的数 int tt = 0; for(int i = 0; i \u003c n; i++) { while(tt \u0026\u0026 stk[tt] \u003e= x) tt--; if(tt) {} else {} stk[++tt] = x; } ","date":"2021-07-10","objectID":"/algorithm_template/:9:5","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"单调队列 //常见模型：求出滑动窗口的最大值/最小值 int hh = 0, tt = -1; for(int i = 0; i \u003c n; i++) { while(hh \u003c= tt \u0026\u0026 q[hh] \u003c i - k + 1) hh++; //判断队头是否滑出窗口 while(hh \u003c= tt \u0026\u0026 a[q[tt]] \u003e= a[i]) tt--; q[++tt] = i; } ","date":"2021-07-10","objectID":"/algorithm_template/:9:6","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"KMP //求next的过程 for(int i = 2, j = 0; i \u003c= n; i++) { while(j \u0026\u0026 p[i] != p[j + 1]) j = next[j]; if(p[i] == p[j + 1]) j++; next[i] = j; } //匹配过程 for(int i = 1, j = 0; i \u003c= m; i++) { //j 总往前错一位 while(j \u0026\u0026 s[i] != p[j + 1]) j = next[j]; if(s[i] == p[j + 1]) j++; if(j==m) { //匹配成功后的逻辑 } } ","date":"2021-07-10","objectID":"/algorithm_template/:9:7","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"Trie数 int son[N][26], cnt[N], idx; // 0号点既是根节点，又是空节点 // son[][]存储树中每个节点的子节点 // cnt[]存储以每个节点结尾的单词数量 void insert(char* str) { int p = 0; for(int i = 0; str[i]; i++) { int u = str[i] - 'a'; if(!son[p][u]) son[p][u] = ++idx; p = son[p][u]; } cnt[p]++; } int query(char *str) { int p = 0; for(int i = 0; str[i]; i++) { int u = str[i] - 'a'; if(!son[p][u]) return 0; p = son[p][u]; } return cnt[p]; } ","date":"2021-07-10","objectID":"/algorithm_template/:9:8","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"并查集 //作用: //1.将两个集合合并 //2.询问两个元素是否在一个集合中 //朴素并查集 int p[N]; int find(int x) { if(p[x] != x) p[x] = find(p[x]); return p[x]; } //合并操作 p[find(a)] = find(b); //维护size的并查集 int p[N], size[N]; int find(int x) { if(p[x] != x) p[x] = find(p[x]); return p[x]; } //合并操作 size[find(b)] += size[find(a)]; p[find(a)] = find(b); ","date":"2021-07-10","objectID":"/algorithm_template/:9:9","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"堆 int h[N], size; for(int i = n/2; i; i--) down(i); //和左右孩子进行比较 void down(int u) { int t = u; if(t * 2 \u003c= size \u0026\u0026 h[t * 2] \u003c h[u]) t = u * 2; if(t * 2 + 1 \u003c= size \u0026\u0026 h[t * 2 + 1] \u003c h[u]) t = u * 2 + 1; if(t != u) { swap(h[t], h[u]); down(t); } } void up(int u) { while(u / 2 \u0026\u0026 h[u / 2] \u003e h[u]) { swap(h[u / 2], h[u]); u = u / 2; } } ","date":"2021-07-10","objectID":"/algorithm_template/:9:10","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"哈希表 //拉链法 int h[N], e[N], ne[N], idx; void insert(int x) { int k = (x % N + N) % N; e[idx] = x, ne[idx] = h[k], h[k] = idx++; } bool find(int x) { int k = (x % N + N) % N; for (int i = h[k]; i != -1; i = ne[i]) if (e[i] == x) return true; return false; } ","date":"2021-07-10","objectID":"/algorithm_template/:9:11","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"STL ","date":"2021-07-10","objectID":"/algorithm_template/:10:0","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"vector vector\u003cint\u003e a; //所有容器均有的操作 a.size(); a.empty(); a.clear(); front()/back(); push_back()/pop_back(); begin()/end(); 支持比较运算; ","date":"2021-07-10","objectID":"/algorithm_template/:10:1","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"pair pair\u003cint, int\u003e p; p = make_pair(123, 345)/p = {123, 345}; p.first/p.second; ","date":"2021-07-10","objectID":"/algorithm_template/:10:2","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"string clear(); sub_str(int startindex, int len); c_str() 返回字符数组的启示地址; ","date":"2021-07-10","objectID":"/algorithm_template/:10:3","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"queue push()/pop(); front()/back(); //清空 q = queue\u003cint\u003e(); ","date":"2021-07-10","objectID":"/algorithm_template/:10:4","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"priority_queue push()/pop(); top(); //默认是大根堆，实现小根堆 1.插入负数； 2.priority_queue\u003cint, vector\u003cint\u003e, greater\u003cint\u003e\u003e heap; ","date":"2021-07-10","objectID":"/algorithm_template/:10:5","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"stack push()/pop(); top(); ","date":"2021-07-10","objectID":"/algorithm_template/:10:6","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"deque //速度较慢 front()/back(); push_back()/pop_back(); push_front()/pop_front(); begin()/end(); ","date":"2021-07-10","objectID":"/algorithm_template/:10:7","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"set / multiset //set没有重复元素 multiset可以有 insert(); find();//不存在返回end迭代器 count(); //某个数个数 erase(); //可以删除所有数，也可以删除单个迭代器 lower_bound()/ upper_bound(); //返回 \u003e= x最小的数 / 返回 \u003e x最小的数 没有返回end() ","date":"2021-07-10","objectID":"/algorithm_template/:10:8","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"map / multimap insert(); erase(); find(); lower_bound()/ upper_bound(); ","date":"2021-07-10","objectID":"/algorithm_template/:10:9","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"unorder_set / unorder_multiset / unorder_map / unordered_multimap // 所有操作O(1) // 不支持lower_bound() upper_end(); being() end() ","date":"2021-07-10","objectID":"/algorithm_template/:10:10","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"bitset bitset\u003c10000\u003e b; ~ | \u0026 ^; \u003c\u003c \u003e\u003e; == !=; count(); any() //判读是否至少有一个1 none() //判断是否全为0 set(k, v) reset() //将所有数取反 flip() //取反 ","date":"2021-07-10","objectID":"/algorithm_template/:10:11","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"动态规划 无后效性，动态规划要求求解的子问题不受后续阶段的影响。换言之，动态规划对状态空间的遍历构成一张有向无环图，遍历该有向无环图就是一个拓扑序，有向无环图中每个节点对应不同的状态，图中的边对应状态之间的转移。 ","date":"2021-07-10","objectID":"/algorithm_template/:11:0","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"背包问题 01背包 //考虑前i个物品，且总体积不大于j的所有选法 int v[N], w[N]; int f[N][N]; for(int i = 1; i \u003c= n; i++) { for(int j = 0; j \u003c= m; j++) { f[i][j] = f[i - 1][j]; if(j \u003e= v[i]) f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]); } } //优化 int f[N]; for(int i = 1; i \u003c= n; i++) { for(int j = m; j \u003e= w[i]; j--) { f[j] = max(f[j], f[j - v[i]] + w[i]); } } 完全背包 for(int i = 1; i \u003c= n; i++) for(int j = 0; j \u003c= m; j++) for(int k = 0; k * v[i] \u003c= j; k++) f[i][j] = max(f[i][j], f[i - 1][j - k * v[i]] + k * w[i]) /*优化 f[i, j] = max(f[i - 1][j], f[i - 1][j - v] + w, f[i - 1][j - 2*v] + 2*w + .....) f[i, j -v] = max( f[i - 1][j - v], f[i - 1][j - 2* v]......) */ for(int i = 1; i \u003c= n; i++) for(int j = 0; j \u003c= m; j++) { f[i][j] = f[i - 1][j]; if(j \u003e= v[i]) f[i][j] = max(f[i][j], f[i][j - v[i]] + w[i]); } //优化(区别于01背包的遍历顺序) for(int i = 1; i \u003c= n; i++) { for(int j = v[i], j \u003c= m; j++) { f[j] = max(f[j], f[j - v[i]] + w[i]); } } 多重背包 //将多重背包转化为01背包(二进制优化) while(k \u003c= s) { cnt++; v[cnt] = a * k; w[cnt] = b * k; s -= k; k *= 2; } if(s \u003e 0) { cnt++; v[cnt] = a * s; w[cnt] = b * s; } n = cnt; for(int i = 1; i \u003c= n; i++) { for(int j = m; j \u003e= w[i]; j--) { f[j] = max(f[j], f[j - v[i]] + w[i]); } } 分组背包问题 for(int i = 0; i \u003c n; i++) { for(int j = m; j \u003e= 0; j--) { for(int k = 0; k \u003c s[i]; k++) if(v[i]][k] \u003c= j) f[j] = max(f[j], f[j - v[i][k]] + w[i][k]); } } ","date":"2021-07-10","objectID":"/algorithm_template/:11:1","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"线性DP 数组三角形 最长上升子序列 for(int i = 0; i \u003c n; i++) { f[i] = 1; for(int j = 0; j \u003c i; j++) { if(f[i] \u003e f[j]) f[i] = max(f[i], f[j] + 1) } } //求路线 for(int i = 0; i \u003c n; i++) { f[i] = 1; g[i] = 0; for(int j = 0; j \u003c i; j++) { if(f[i] \u003e f[j]) if(f[i] \u003c f[j] + 1) { f[i] = f[j] + 1; g[i] = j; } } } for(int i = 0, len = f[k]; i \u003c len; i++) { printf(\"%d\", g[k]); k = g[k]; } 最长上升子序列II for(int i = 0; i \u003c n; i++) { int l = 0, r = len; while(l \u003c r) { int mid = (l + r + 1) / 2; if(q[mid] \u003c a[i]) l = mid; else r = mid - 1; } len = max(len, r + 1); q[r + 1] = a[i]; } 最长公共子序列 for(int i = 1; i \u003c= n; i++) { for(int j = 1; j \u003c= m; j++) { f[i][j] = max(f[i - 1][j], f[i][j - 1]); if(a[i] == b[j]) f[i][j] = max(f[i][j], f[i - 1][j - 1] + 1); } } 编辑距离 for(int i = 0; i \u003c= m; i++) f[0][i] = i; for(int i = 0; i \u003c= n; i++) f[i][0] = i; for(int i = 1; i \u003c= n; i++) { for(int j = 1; j \u003c= m; j++) { f[i][j] = min(f[i - 1][j], f[i][j - 1]); if(a[i] == b[j]) f[i][j] = min(f[i][j], f[i - 1][j - 1]); else f[i][j] = min(f[i][j], f[i - 1][j - 1] + 1); } } ","date":"2021-07-10","objectID":"/algorithm_template/:11:2","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"区间DP 石子合并 for(int len = 2; len \u003c= n; len++) { for(int i = 1; i + len - 1\u003c= n; i++) { int l = i, r = i + len - 1; f[i][j] = 1e8; for(int k = i, k \u003c r; k++) { f[l][r] = min(f[l][r], f[l][k] + f[k + 1][r] + s[r] - s[l - 1]); } } } ","date":"2021-07-10","objectID":"/algorithm_template/:11:3","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"计数DP 整数划分 //背包做法 f[i][j] = f[i - 1][j] + f[i - 1][j - i] + f[i - 1][j - 2i] +... f[i - 1][j - si]; f[i][j - 1] = f[i - 1][j - 1] + f[i - 1][j - 2i] +... f[i - 1][j - si]; f[i][j] = f[i - 1][j] + f[i][j - 1]; for(int i = 1; i \u003c=n ;i++) for(int j = i; j \u003c= n; j++) { f[j] = (f[j] + f[j - 1]) % mod; } //计数dp //集合：所有总和为i,并且恰好表示成j个数的和的方案 for(int i = 1; i \u003c= n; i++) { for(int j = 1; j \u003c= i; j++) { f[i][j] = (f[i - 1][j] + f[i - j][j]) % mod } } return f[n][1] + .....f[n][n]; ","date":"2021-07-10","objectID":"/algorithm_template/:11:4","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"数位DP 数字统计 ","date":"2021-07-10","objectID":"/algorithm_template/:11:5","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"搜索和图论 ","date":"2021-07-10","objectID":"/algorithm_template/:12:0","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"DFS ","date":"2021-07-10","objectID":"/algorithm_template/:12:1","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"BFS ","date":"2021-07-10","objectID":"/algorithm_template/:12:2","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"邻接表 int h[N], e[N], ne[N], idx; init() { memset(h, -1, sizeof h); idx = 0; } void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx, idx++; } ","date":"2021-07-10","objectID":"/algorithm_template/:12:3","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"拓扑排序 bool toposort() { int hh = 0, tt = -1; for(int i = 1; i \u003c= n; i++) { if(!d[i]) q[++tt] = i; } while(hh \u003c= tt) { int t = qq[hh++]; for(int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; d[j]--; if(d[j] == 0) q[++tt] = j; } } return tt == n - 1; } ","date":"2021-07-10","objectID":"/algorithm_template/:12:4","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"单源最短路 //所有边权均为正数 //朴素Dijkstra O(n^2) //适合稠密图 int g[N][N]; int dist[N]; bool st[N]; int dijkstra() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; for(int i = 0; i \u003c n; i++) { int t = -1; for(int j = 1; j \u003c= n; j++) { if(!st[j] \u0026\u0026 (t == -1 || dist[t] \u003e dist[j])) t = j; } st[t] = 1; for(int j = 1; j \u003c= n; j++) { dist[j] = min(dist[j], dist[t] + g[t][j]); } } if(dist[n] == 0x3f) return -1; return dist[n]; } //堆优化版的Dijkstra //适合稀疏图 //O(mlogn) typedef pair\u003cint, int\u003e PII; int h[N], w[N], e[N], ne[N], idx; int dist[N]; bool st[N]; int dijkstra() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; st[1] = true; priority_queue\u003cPII, vector\u003cPII\u003e, greater\u003cPII\u003e\u003e heap; heap.push({0, 1}); while(heap.size()) { auto t = heap.top(); heap.pop(); int ver = t.second, dis = t.first; if(st[ver]) continue; st[ver] = true; for(int i = h[ver]; i != -1; i = ne[i]) { int j = e[i]; if(dist[j] \u003e dis + w[i]) { dist[j] = dis + w[i]; heap.push({dist[j], j}); } } } if(dist[n] == 0x3f3f3f3f) return -1; return dist[n]; } //存在负权边情况 //Bellman- Ford算法 //O(nm) int dist[N], backup[N]; struct Edge { int a, b, w; }edges[M]; int bellman_ford() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; for(int i = 0; i \u003c k; i++) { //避免后效性 memcpy(backup, dist, sizeof dist); for(int j = 0; j \u003c m; j++) { int a = edges[j].a; int b = edges[j].b; int w = edges[j].w; dist[b] = min(dist[b], backup[a] + w); } } // 两个正无穷的点之间的边是负的情况 if(dist[n] \u003e 0x3f3f3f3f / 2) return -1; return dist[n]; } //SPFA算法 是对Bellman-ford进行优化 一般O(m) 最坏O(nm) //利用广度优先算法进行优化 int spfa() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; st[1] = true; queue\u003cint\u003e q; q.push(1); while(q.size()) { int t = q.front(); q.pop(); st[t] = false; for(int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if(dist[j] \u003e dist[t] + w[i]) { dist[j] = dist[t] + w[i]; if(!st[j]) { q.push(j); st[j] = true; } } } } if(dist[n] == 0x3f3f3f3f) return -1; return dist[n]; } //拓展 spfa判断负环 //维护一个cnt数组 cnt[i] \u003e= n则有负环 bool spfa() { memset(dist, 0x3f, sizeof dist); queue\u003cint\u003e q; for(int i = 1; i \u003c= n; i++) { st[i] = true; q.push(i); } while(q.size()) { int t = q.front(); q.pop(); st[t] = false; for(int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if(dist[j] \u003e dist[t] + w[i]) { dist[j] = dist[t] + w[i]; cnt[j] = cnt[t] + 1; if(cnt[j] \u003e= n) return true; if(!st[j]) { q.push(j); st[j] = true; } } } } return false; } ","date":"2021-07-10","objectID":"/algorithm_template/:12:5","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"多源汇最短路 //Floyd //O(n^3) void floyd() { for(int k = 1; k \u003c= n; k++) { for(int i = 1; i \u003c= n; i++) { for(int j = 1; j \u003c= n; j++) { d[i][j] = min(d[i][j], d[i][k] + d[k][j]); } } } } ","date":"2021-07-10","objectID":"/algorithm_template/:12:6","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"最小生成树 //Prim //适合稠密图 //O(n^2) int prim() { memset(dist, 0x3f, sizeof dist); int res = 0; for(int i = 0; i \u003c n; i++) { int t = -1; for(int j = 1; j \u003c= n; j++) { if(!st[j] \u0026\u0026 (t == -1 || dist[t] \u003c dist[j])) t = j; if(i \u0026\u0026 dist[t] == INF) return INF; if(i) res += dist[t]; for(int j = 1; j \u003c= n; j++) dist[j] = min(dist[j], g[t][j]); st[t] = true; } } return res; } //Kruskal //适合稀疏图 //O(mlogm) struct Edges { int a, b, w; operator \u003c(const Edges\u0026 W) const { return w \u003c W.w; } }edegs[m]; sort(edegs, edges + m); for(int i = 1; i \u003c= n; i++) p[i] = i; int res = 0, cnt = 0; for(int i = 0; i \u003c m; i++) { int a = edges[i].a; int b = edges[i].b; int w = edges[i].w; a = find(a), b = find(b); if(a != b) { res += w; cnt++; p[a] = b; } } if(cnt \u003c n - 1) return -1; else return res; ","date":"2021-07-10","objectID":"/algorithm_template/:12:7","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"二分图 //染色法 //O(n + m) //二分图 当且仅当图中不含奇数环 bool flag = false; bool dfs(int u, int c) { for(int i = h[u]; i != -1; i = ne[i]) { int j = e[i]; if(!color[j]) { return dfs(j, 3 - c); } else if(color[j] == c) return false; } return true; } for(int i = 0; i \u003c= n; i++) { if(!color[i]) { if(!dfs(i, 1)) { flag = false; break; } } } //匈牙利算法 //O(mn) bool find(int x) { for(int i = h[x]; i != -1; i = ne[i]) { int j = e[i]; if(!st[j]) { st[j] = true; if(match[j] == 0 || find(match[j])) { match[j] = x; return true; } } } return false; } for(int i = 1; i \u003c= n1; i++) { memset(st, false, sizeof st); if(find(i)) res++; printf(\"%d\\n\", res); } ","date":"2021-07-10","objectID":"/algorithm_template/:12:8","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":["leetcode"],"content":"线段树 //线段树是一种二叉搜索树，将一段区间划分为若干单位区间，每一个节点都存储着一个区间 //支持单点修改，区间求和，区间求最值，区间修改 struct Node { int l, r; int v; } tree[N * 4]; //建树 void build(int u, int l, int r) { tree[u] = {l, r}; if(l == r) return; int mid = l + r \u003e\u003e 1; build(u \u003c\u003c 1, l, mid); build(u \u003c\u003c 1 | 1, mid + 1, r); } //更新 void push_up(int u) { tree[u].v = max(tree[u \u003c\u003c 1].v, tree[u \u003c\u003c 1 | 1]. v); } //查询 int query(int u, int l, int r) { if(tree[u].l \u003e= l \u0026\u0026 tree[u].r \u003c= r) return tree[u].v; int mid = tree[u].l + tree[u].r \u003e\u003e 1; int v = 0; if(l \u003c= mid) v = query(u \u003c\u003c 1, l, r); if(r \u003e mid) v = max(v, query(u \u003c\u003c 1 | 1, l, r)); return v; } //修改 void modify(int u, int x, int v) { if(tree[u].l == x \u0026\u0026 tree[u].r == x) tree[u].v = v; else { int mid = tree[u].l + tree[u].r \u003e\u003e 1; if(x \u003c= mid) modify(u \u003c\u003c 1, x, v); else modify(u \u003c\u003c 1 | 1, x, v); tree[u].v = max(tree[u \u003c\u003c 1].v , tree[u \u003c\u003c 1 | 1].v); } } ","date":"2021-07-10","objectID":"/algorithm_template/:13:0","tags":["算法"],"title":"算法题模板","uri":"/algorithm_template/"},{"categories":null,"content":" 想不出来 :D ","date":"0001-01-01","objectID":"/about/:0:0","tags":null,"title":"关于","uri":"/about/"}]